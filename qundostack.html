<html>
<head>
<title>QUndoStack Class Reference</title>
<style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr></tr>
<td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" tppabs="http://pyqt4doc.appspot.com/images/rb-logo.png" width="32"></td>
<td width="1">  </td>
<td class="postheader" valign="center">
<a href="index.html" tppabs="http://pyqt4doc.appspot.com/index.html"><font color="#004faf">Home</font></a> · <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/classes.html"><font color="#004faf">All Classes</font></a> · <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/modules.html"><font color="#004faf">Modules</font></a>  · <a href="qss.html"><font color="#004faf">QSS HELP</font></a>  · <a href="qtqss.html"><font color="#004faf">QSS 案例</font></a> · <a href="HTTP://VER007.COM"><font color="#004faf">VER007 HOME</font></a> 
</td>
</table>
<h1 align="center">QUndoStack Class Reference<br><sup><sup>[<a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qtgui.html">QtGui</a> module]</sup></sup>
</h1>
<p>该QUndoStack类是一个堆栈的<a href="qundocommand.html" tppabs="http://pyqt4doc.appspot.com/qundocommand.html">QUndoCommand</a>对象。<a href="#details">More...</a></p>

<p>继承<a href="qobject.html" tppabs="http://pyqt4doc.appspot.com/qobject.html">QObject</a>。</p>
<h3>Methods</h3>
<ul>
<li>
<div class="fn"></div>
<b><a href="qundostack.html#QUndoStack" tppabs="http://pyqt4doc.appspot.com/qundostack.html#QUndoStack">__init__</a></b> (<i>self</i>, QObject <i>parent</i> = None)</li>
<li>
<div class="fn"></div>
<b><a href="qundostack.html#beginMacro" tppabs="http://pyqt4doc.appspot.com/qundostack.html#beginMacro">beginMacro</a></b> (<i>self</i>, QString <i>text</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qundostack.html#canRedo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#canRedo">canRedo</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qundostack.html#canUndo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#canUndo">canUndo</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qundostack.html#cleanIndex" tppabs="http://pyqt4doc.appspot.com/qundostack.html#cleanIndex">cleanIndex</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qundostack.html#clear" tppabs="http://pyqt4doc.appspot.com/qundostack.html#clear">clear</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QUndoCommand <b><a href="qundostack.html#command" tppabs="http://pyqt4doc.appspot.com/qundostack.html#command">command</a></b> (<i>self</i>, int <i>index</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qundostack.html#count" tppabs="http://pyqt4doc.appspot.com/qundostack.html#count">count</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QAction <b><a href="qundostack.html#createRedoAction" tppabs="http://pyqt4doc.appspot.com/qundostack.html#createRedoAction">createRedoAction</a></b> (<i>self</i>, QObject <i>parent</i>, QString <i>prefix</i> = QString())</li>
<li>
<div class="fn"></div>QAction <b><a href="qundostack.html#createUndoAction" tppabs="http://pyqt4doc.appspot.com/qundostack.html#createUndoAction">createUndoAction</a></b> (<i>self</i>, QObject <i>parent</i>, QString <i>prefix</i> = QString())</li>
<li>
<div class="fn"></div>
<b><a href="qundostack.html#endMacro" tppabs="http://pyqt4doc.appspot.com/qundostack.html#endMacro">endMacro</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qundostack.html#index" tppabs="http://pyqt4doc.appspot.com/qundostack.html#index">index</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qundostack.html#isActive" tppabs="http://pyqt4doc.appspot.com/qundostack.html#isActive">isActive</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qundostack.html#isClean" tppabs="http://pyqt4doc.appspot.com/qundostack.html#isClean">isClean</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qundostack.html#push" tppabs="http://pyqt4doc.appspot.com/qundostack.html#push">push</a></b> (<i>self</i>, QUndoCommand <i>cmd</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QString <b><a href="qundostack.html#redoText" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redoText">redoText</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qundostack.html#setActive" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setActive">setActive</a></b> (<i>self</i>, bool <i>active</i> = True)</li>
<li>
<div class="fn"></div>
<b><a href="qundostack.html#setClean" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setClean">setClean</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qundostack.html#setIndex" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setIndex">setIndex</a></b> (<i>self</i>, int <i>idx</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qundostack.html#setUndoLimit" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setUndoLimit">setUndoLimit</a></b> (<i>self</i>, int <i>limit</i>)</li>
<li>
<div class="fn"></div>QString <b><a href="qundostack.html#text" tppabs="http://pyqt4doc.appspot.com/qundostack.html#text">text</a></b> (<i>self</i>, int <i>idx</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qundostack.html#undo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undo">undo</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qundostack.html#undoLimit" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undoLimit">undoLimit</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QString <b><a href="qundostack.html#undoText" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undoText">undoText</a></b> (<i>self</i>)</li>
</ul>
<h3>Special Methods</h3>
<ul><li>
<div class="fn"></div> <b><a href="qundostack.html#__len__" tppabs="http://pyqt4doc.appspot.com/qundostack.html#__len__">__len__</a></b> (<i>self</i>)</li></ul>
<h3>Qt Signals</h3>
<ul>
<li>
<div class="fn"></div>void <b><a href="qundostack.html#canRedoChanged" tppabs="http://pyqt4doc.appspot.com/qundostack.html#canRedoChanged">canRedoChanged</a></b> (bool)</li>
<li>
<div class="fn"></div>void <b><a href="qundostack.html#canUndoChanged" tppabs="http://pyqt4doc.appspot.com/qundostack.html#canUndoChanged">canUndoChanged</a></b> (bool)</li>
<li>
<div class="fn"></div>void <b><a href="qundostack.html#cleanChanged" tppabs="http://pyqt4doc.appspot.com/qundostack.html#cleanChanged">cleanChanged</a></b> (bool)</li>
<li>
<div class="fn"></div>void <b><a href="qundostack.html#indexChanged" tppabs="http://pyqt4doc.appspot.com/qundostack.html#indexChanged">indexChanged</a></b> (int)</li>
<li>
<div class="fn"></div>void <b><a href="qundostack.html#redoTextChanged" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redoTextChanged">redoTextChanged</a></b> (const QString&amp;)</li>
<li>
<div class="fn"></div>void <b><a href="qundostack.html#undoTextChanged" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undoTextChanged">undoTextChanged</a></b> (const QString&amp;)</li>
</ul>
<a name="details"></a><div class="ad">
<hr>
 
</div>
<h2>Detailed Description</h2>
<p>该QUndoStack类是一个堆栈的<a href="qundocommand.html" tppabs="http://pyqt4doc.appspot.com/qundocommand.html">QUndoCommand</a>对象。</p>
<p>对于Qt的复原框架的概述，请参阅<a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qundo.html">overview document</a>。</p>
<p>一个撤消堆栈保持堆栈已应用于文档的命令。</p>
<p>新的命令使用压入堆栈<a href="qundostack.html#push" tppabs="http://pyqt4doc.appspot.com/qundostack.html#push">push</a>（ ） 。命令可以撤消和重做的使用<a href="qundostack.html#undo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undo">undo</a>（）和<a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a>（ ） ，或通过触发返回的行动<a href="qundostack.html#createUndoAction" tppabs="http://pyqt4doc.appspot.com/qundostack.html#createUndoAction">createUndoAction</a>（）和<a href="qundostack.html#createRedoAction" tppabs="http://pyqt4doc.appspot.com/qundostack.html#createRedoAction">createRedoAction</a>（ ） 。</p>
<p>QUndoStack跟踪的<i>current</i>命令。这是将由下一个呼叫要执行的命令<a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a>（ ） 。这个命令的指数是由返回<a href="qundostack.html#index" tppabs="http://pyqt4doc.appspot.com/qundostack.html#index">index</a>（ ） 。编辑的对象的状态可以卷向前或向后使用<a href="qundostack.html#setIndex" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setIndex">setIndex</a>（ ） 。如果堆栈最上面的命令已经被重做，<a href="qundostack.html#index" tppabs="http://pyqt4doc.appspot.com/qundostack.html#index">index</a>（ ）等于<a href="qundostack.html#count" tppabs="http://pyqt4doc.appspot.com/qundostack.html#count">count</a>（ ） 。</p>
<p>QUndoStack提供支持撤消和重做操作，命令压缩，命令宏和支持的概念<i>clean
state</i>。</p>
<a id="undo-and-redo-actions" name="undo-and-redo-actions"></a>
<h3>Undo and Redo Actions</h3>
<p>QUndoStack提供方便的撤销和重做<a href="qaction.html" tppabs="http://pyqt4doc.appspot.com/qaction.html">QAction</a>对象，它们可以被插入到一个菜单或工具栏上。当命令被撤消或重做， QUndoStack更新这些行动的文本属性，以反映什么样的变化，他们将触发。当没有命令可用于撤消或重做的动作也被禁用。这些行动是由返回<a href="qundostack.html#createUndoAction" tppabs="http://pyqt4doc.appspot.com/qundostack.html#createUndoAction">QUndoStack.createUndoAction</a>（）和<a href="qundostack.html#createRedoAction" tppabs="http://pyqt4doc.appspot.com/qundostack.html#createRedoAction">QUndoStack.createRedoAction</a>（ ） 。</p>
<a id="command-compression-and-macros" name="command-compression-and-macros"></a>
<h3>Command Compression and Macros</h3>
<p>当几个命令可以被压缩成可以撤消一个命令，并在重做一个单一的操作命令压缩是非常有用的。例如，当用户在文本编辑字符时，一个新的命令被创建。这个命令插入字符插入到文档中光标所在的位置。但是，对于用户更加方便，能够撤消或重做整个单词，句子或段落打字。命令压缩使这些单字符命令合并到其中插入或删除文本部分的单一命令。欲了解更多信息，请参见<a href="qundocommand.html#mergeWith" tppabs="http://pyqt4doc.appspot.com/qundocommand.html#mergeWith">QUndoCommand.mergeWith</a>（）和<a href="qundostack.html#push" tppabs="http://pyqt4doc.appspot.com/qundostack.html#push">push</a>（ ） 。</p>
<p>命令宏命令，所有这一切都是撤消和重做一次过的序列。命令宏被赋予一个命令子命令列表创建的。撤消或重做父的命令会让孩子命令撤消或重做。命令宏可以显式的指定在一个父级要创建<a href="qundocommand.html" tppabs="http://pyqt4doc.appspot.com/qundocommand.html">QUndoCommand</a>构造函数，或者使用的方便功能<a href="qundostack.html#beginMacro" tppabs="http://pyqt4doc.appspot.com/qundostack.html#beginMacro">beginMacro</a>（）和<a href="qundostack.html#endMacro" tppabs="http://pyqt4doc.appspot.com/qundostack.html#endMacro">endMacro</a>（ ） 。</p>
<p>虽然压缩命令和宏似乎有同样的效果给用户，他们往往有不同的用途中的应用程序。执行的微小变化到一个文件的命令可以有效地压缩，如果没有必要单独地记录它们，并且如果只有较大的变化是相关的用户。然而，对于需要被单独记录的，或者是那些不能被压缩的命令，这是很有用的宏，以提供更方便的用户体验，同时保持每个命令的记录。</p>
<a id="clean-state" name="clean-state"></a>
<h3>Clean State</h3>
<p>QUndoStack支持的清洁状态的概念。当文件被保存到磁盘，堆栈可以使用被标记为干净<a href="qundostack.html#setClean" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setClean">setClean</a>（ ） 。只要堆栈通过撤销和重做命令返回到这个状态，它发出的信号<a href="qundostack.html#cleanChanged" tppabs="http://pyqt4doc.appspot.com/qundostack.html#cleanChanged">cleanChanged</a>（ ） 。当堆栈离开干净的状态，这个信号被发射也。这个信号通常是用来启用和禁用应用程序中保存的动作，并更新文档的标题，以反映它包含未保存的更改。</p>
<hr>
<h2>Method Documentation</h2>
<h3 class="fn">
<a name="QUndoStack"></a>QUndoStack.__init__ (<i>self</i>, <a href="qobject.html" tppabs="http://pyqt4doc.appspot.com/qobject.html">QObject</a> <i>parent</i> = None)</h3>
<p>该<i>parent</i>的说法，如果不是没有，原因<i>self</i>通过Qt的，而不是PyQt的拥有。</p>
<p>构造一个空撤消堆栈与父<i>parent</i>。该协议栈将首先在干净的状态。如果<i>parent</i>是<a href="qundogroup.html" tppabs="http://pyqt4doc.appspot.com/qundogroup.html">QUndoGroup</a>对象，堆栈会自动添加到组中。</p>
<p><b>See also</b> <a href="qundostack.html#push" tppabs="http://pyqt4doc.appspot.com/qundostack.html#push">push</a>（ ） 。</p>


<h3 class="fn">
<a name="beginMacro"></a>QUndoStack.beginMacro (<i>self</i>, QString <i>text</i>)</h3>
<p>开始一个宏命令组成与给定<i>text</i>描述。</p>
<p>由指定的描述一个空的命令<i>text</i>被压入堆栈。压入堆栈上的任何后续命令将被追加到空命令的孩子，直到<a href="qundostack.html#endMacro" tppabs="http://pyqt4doc.appspot.com/qundostack.html#endMacro">endMacro</a>（）被调用。</p>
<p>调用beginMacro （）和<a href="qundostack.html#endMacro" tppabs="http://pyqt4doc.appspot.com/qundostack.html#endMacro">endMacro</a>（ ）可以嵌套，但每次调用beginMacro （ ）必须有匹配的调用<a href="qundostack.html#endMacro" tppabs="http://pyqt4doc.appspot.com/qundostack.html#endMacro">endMacro</a>（ ） 。</p>
<p>虽然宏组成，堆栈被禁用。这意味着：</p>
<ul>
<li>
<a href="qundostack.html#indexChanged" tppabs="http://pyqt4doc.appspot.com/qundostack.html#indexChanged">indexChanged</a>() and
<a href="qundostack.html#cleanChanged" tppabs="http://pyqt4doc.appspot.com/qundostack.html#cleanChanged">cleanChanged</a>() are not
emitted,</li>
<li>
<a href="qundostack.html#canUndo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#canUndo">canUndo</a>() and <a href="qundostack.html#canRedo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#canRedo">canRedo</a>() return false,</li>
<li>calling <a href="qundostack.html#undo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undo">undo</a>() or <a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a>() has no effect,</li>
<li>the undo/redo actions are disabled.</li>
</ul>
<p>堆栈是可用的，适当的信号被发射时，<a href="qundostack.html#endMacro" tppabs="http://pyqt4doc.appspot.com/qundostack.html#endMacro">endMacro</a>（）被调用用于最外层的宏。</p>
<pre class="cpp">
 stack<span class="operator">.</span>beginMacro(<span class="string">"insert red text"</span>);
 stack<span class="operator">.</span><a href="qundostack.html#push" tppabs="http://pyqt4doc.appspot.com/qundostack.html#push">push</a>(<span class="keyword">new</span> InsertText(document<span class="operator">,</span> idx<span class="operator">,</span> text));
 stack<span class="operator">.</span><a href="qundostack.html#push" tppabs="http://pyqt4doc.appspot.com/qundostack.html#push">push</a>(<span class="keyword">new</span> SetColor(document<span class="operator">,</span> idx<span class="operator">,</span> text<span class="operator">.</span>length()<span class="operator">,</span> <span class="type"><a href="qt.html" tppabs="http://pyqt4doc.appspot.com/qt.html">Qt</a></span><span class="operator">.</span>red));
 stack<span class="operator">.</span><a href="qundostack.html#endMacro" tppabs="http://pyqt4doc.appspot.com/qundostack.html#endMacro">endMacro</a>(); <span class="comment">// indexChanged() is emitted</span>
</pre>
<p>这段代码等同于：</p>
<pre class="cpp">
 <span class="type"><a href="qundocommand.html" tppabs="http://pyqt4doc.appspot.com/qundocommand.html">QUndoCommand</a></span> <span class="operator">*</span>insertRed <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qundocommand.html" tppabs="http://pyqt4doc.appspot.com/qundocommand.html">QUndoCommand</a></span>(); <span class="comment">// an empty command</span>
 insertRed<span class="operator">-</span><span class="operator">&gt;</span>setText(<span class="string">"insert red text"</span>);

 <span class="keyword">new</span> InsertText(document<span class="operator">,</span> idx<span class="operator">,</span> text<span class="operator">,</span> insertRed); <span class="comment">// becomes child of insertRed</span>
 <span class="keyword">new</span> SetColor(document<span class="operator">,</span> idx<span class="operator">,</span> text<span class="operator">.</span>length()<span class="operator">,</span> <span class="type"><a href="qt.html" tppabs="http://pyqt4doc.appspot.com/qt.html">Qt</a></span><span class="operator">.</span>red<span class="operator">,</span> insertRed);

 stack<span class="operator">.</span><a href="qundostack.html#push" tppabs="http://pyqt4doc.appspot.com/qundostack.html#push">push</a>(insertRed);
</pre>
<p><b>See also</b> <a href="qundostack.html#endMacro" tppabs="http://pyqt4doc.appspot.com/qundostack.html#endMacro">endMacro</a>（ ） 。</p>


<h3 class="fn">
<a name="canRedo"></a>bool QUndoStack.canRedo (<i>self</i>)</h3>
<p>返回True如果有可用的重做命令，否则返回False 。</p>
<p>如果堆栈为空或者栈顶的命令已经被重做这个函数返回False 。</p>
<p>代名词<a href="qundostack.html#index" tppabs="http://pyqt4doc.appspot.com/qundostack.html#index">index</a>（）==<a href="qundostack.html#count" tppabs="http://pyqt4doc.appspot.com/qundostack.html#count">count</a>（ ） 。</p>
<p><b>See also</b> <a href="qundostack.html#index" tppabs="http://pyqt4doc.appspot.com/qundostack.html#index">index</a>（）和<a href="qundostack.html#canUndo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#canUndo">canUndo</a>（ ） 。</p>


<h3 class="fn">
<a name="canUndo"></a>bool QUndoStack.canUndo (<i>self</i>)</h3>
<p>返回True如果有可用撤消命令，否则返回False 。</p>
<p>这个函数返回False，如果堆栈为空，或者如果堆栈底部的命令已被撤销。</p>
<p>代名词<a href="qundostack.html#index" tppabs="http://pyqt4doc.appspot.com/qundostack.html#index">index</a>（）== 0 。</p>
<p><b>See also</b> <a href="qundostack.html#index" tppabs="http://pyqt4doc.appspot.com/qundostack.html#index">index</a>（）和<a href="qundostack.html#canRedo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#canRedo">canRedo</a>（ ） 。</p>


<h3 class="fn">
<a name="cleanIndex"></a>int QUndoStack.cleanIndex (<i>self</i>)</h3>
<p>返回干净的索引。这是该指数在这<a href="qundostack.html#setClean" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setClean">setClean</a>（ ）被调用。</p>
<p>堆栈可能没有一个干净的索引。出现这种情况，如果一个文件被保存，一些命令被撤消，那么一个新的命令被按下。自<a href="qundostack.html#push" tppabs="http://pyqt4doc.appspot.com/qundostack.html#push">push</a>（ ）删除所有推新命令之前未完成的指令，堆栈不能返回到干净的状态了。在这种情况下，该函数返回-1 。</p>
<p><b>See also</b> <a href="qundostack.html#isClean" tppabs="http://pyqt4doc.appspot.com/qundostack.html#isClean">isClean</a>（）和<a href="qundostack.html#setClean" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setClean">setClean</a>（ ） 。</p>


<h3 class="fn">
<a name="clear"></a>QUndoStack.clear (<i>self</i>)</h3>
<p>清除命令堆栈删除其上的所有命令，并返回堆栈到干净的状态。</p>
<p>命令都不会撤消或重做;编辑的对象的状态保持不变。</p>
<p>此功能通常用于当该文件的内容被放弃。</p>
<p><b>See also</b> <a href="qundostack.html#QUndoStack" tppabs="http://pyqt4doc.appspot.com/qundostack.html#QUndoStack">QUndoStack</a>（ ） 。</p>


<h3 class="fn">
<a name="command"></a><a href="qundocommand.html" tppabs="http://pyqt4doc.appspot.com/qundocommand.html">QUndoCommand</a> QUndoStack.command (<i>self</i>, int <i>index</i>)</h3>
<p>在返回一个const指针，指向命令<i>index</i>。</p>
<p>这个函数返回一个const指针，因为修改的命令，一旦被压入堆栈和执行的，几乎总是会导致文档的状态的腐败，如果命令是后来撤消或重做。</p>
<p>此功能被引入Qt的4.4 。</p>
<p><b>See also</b> <a href="qundocommand.html#child" tppabs="http://pyqt4doc.appspot.com/qundocommand.html#child">QUndoCommand.child</a>（ ） 。</p>


<h3 class="fn">
<a name="count"></a>int QUndoStack.count (<i>self</i>)</h3>
<p>返回命令的堆栈数。宏命令都算作一个命令。</p>
<p><b>See also</b> <a href="qundostack.html#index" tppabs="http://pyqt4doc.appspot.com/qundostack.html#index">index</a>（ ）<a href="qundostack.html#setIndex" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setIndex">setIndex</a>（）和<a href="qundostack.html#command" tppabs="http://pyqt4doc.appspot.com/qundostack.html#command">command</a>（ ） 。</p>


<h3 class="fn">
<a name="createRedoAction"></a><a href="qaction.html" tppabs="http://pyqt4doc.appspot.com/qaction.html">QAction</a> QUndoStack.createRedoAction (<i>self</i>, <a href="qobject.html" tppabs="http://pyqt4doc.appspot.com/qobject.html">QObject</a> <i>parent</i>, QString <i>prefix</i> = QString())</h3>
<p>该<i>parent</i>的说法，如果不是没有，原因<i>self</i>通过Qt的，而不是PyQt的拥有。</p>
<p>创建一个重做<a href="qaction.html" tppabs="http://pyqt4doc.appspot.com/qaction.html">QAction</a>与给定对象<i>parent</i>。</p>
<p>触发此动作将导致调用<a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a>（ ） 。这个动作的文本命令，将在下一呼叫重做文本<a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a>（ ） ，前缀由指定的<i>prefix</i>。如果没有可用的重做命令，这个动作将被禁用。</p>
<p>If <i>prefix</i>为空，则默认模板“重做％ 1 ”是用来代替前缀。 Qt的4.8之前，前缀“重做”被默认使用。</p>
<p><b>See also</b> <a href="qundostack.html#createUndoAction" tppabs="http://pyqt4doc.appspot.com/qundostack.html#createUndoAction">createUndoAction</a>（ ）<a href="qundostack.html#canRedo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#canRedo">canRedo</a>（）和<a href="qundocommand.html#text" tppabs="http://pyqt4doc.appspot.com/qundocommand.html#text">QUndoCommand.text</a>（ ） 。</p>


<h3 class="fn">
<a name="createUndoAction"></a><a href="qaction.html" tppabs="http://pyqt4doc.appspot.com/qaction.html">QAction</a> QUndoStack.createUndoAction (<i>self</i>, <a href="qobject.html" tppabs="http://pyqt4doc.appspot.com/qobject.html">QObject</a> <i>parent</i>, QString <i>prefix</i> = QString())</h3>
<p>该<i>parent</i>的说法，如果不是没有，原因<i>self</i>通过Qt的，而不是PyQt的拥有。</p>
<p>创建一个撤消<a href="qaction.html" tppabs="http://pyqt4doc.appspot.com/qaction.html">QAction</a>与给定对象<i>parent</i>。</p>
<p>触发此动作将导致调用<a href="qundostack.html#undo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undo">undo</a>（ ） 。这个动作的文本将在下一呼叫撤消命令的文本<a href="qundostack.html#undo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undo">undo</a>（ ） ，前缀由指定的<i>prefix</i>。如果没有可用的undo命令，这个动作将被禁用。</p>
<p>If <i>prefix</i>为空，则使用默认模板，而不是前缀“还原％ 1 ” 。 Qt的4.8之前，前缀“撤消”被默认使用。</p>
<p><b>See also</b> <a href="qundostack.html#createRedoAction" tppabs="http://pyqt4doc.appspot.com/qundostack.html#createRedoAction">createRedoAction</a>（ ）<a href="qundostack.html#canUndo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#canUndo">canUndo</a>（）和<a href="qundocommand.html#text" tppabs="http://pyqt4doc.appspot.com/qundocommand.html#text">QUndoCommand.text</a>（ ） 。</p>


<h3 class="fn">
<a name="endMacro"></a>QUndoStack.endMacro (<i>self</i>)</h3>
<p>结束一个宏命令组成。</p>
<p>如果是这样的最外层的宏在一组嵌套的宏，该功能会发出<a href="qundostack.html#indexChanged" tppabs="http://pyqt4doc.appspot.com/qundostack.html#indexChanged">indexChanged</a>（ ）一旦整个宏命令。</p>
<p><b>See also</b> <a href="qundostack.html#beginMacro" tppabs="http://pyqt4doc.appspot.com/qundostack.html#beginMacro">beginMacro</a>（ ） 。</p>


<h3 class="fn">
<a name="index"></a>int QUndoStack.index (<i>self</i>)</h3>
<p>返回当前指令的索引。这是将要到下一个调用执行的命令<a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a>（ ） 。它并不总是在堆栈中最上面的命令，因为一些命令可能已被撤消。</p>
<p><b>See also</b> <a href="qundostack.html#setIndex" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setIndex">setIndex</a>（ ）<a href="qundostack.html#undo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undo">undo</a>（ ）<a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a>（）和<a href="qundostack.html#count" tppabs="http://pyqt4doc.appspot.com/qundostack.html#count">count</a>（ ） 。</p>


<h3 class="fn">
<a name="isActive"></a>bool QUndoStack.isActive (<i>self</i>)</h3>
<h3 class="fn">
<a name="isClean"></a>bool QUndoStack.isClean (<i>self</i>)</h3>
<p>如果堆栈是在干净的状态，返回True，否则返回False 。</p>
<p><b>See also</b> <a href="qundostack.html#setClean" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setClean">setClean</a>（）和<a href="qundostack.html#cleanIndex" tppabs="http://pyqt4doc.appspot.com/qundostack.html#cleanIndex">cleanIndex</a>（ ） 。</p>


<h3 class="fn">
<a name="push"></a>QUndoStack.push (<i>self</i>, <a href="qundocommand.html" tppabs="http://pyqt4doc.appspot.com/qundocommand.html">QUndoCommand</a> <i>cmd</i>)</h3>
<p>该<i>cmd</i>说法有它的所有权转移给Qt的。</p>
<p>Pushes <i>cmd</i>在堆栈上或与最近执行的命令将其合并。在任一情况下，执行时<i>cmd</i>通过调用其<a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a>（）函数。</p>
<p>If <i>cmd</i>的ID不是-1，如果ID是相同的最近执行的命令的，<a href="qundostack.html" tppabs="http://pyqt4doc.appspot.com/qundostack.html">QUndoStack</a>将尝试通过调用合并两个命令<a href="qundocommand.html#mergeWith" tppabs="http://pyqt4doc.appspot.com/qundocommand.html#mergeWith">QUndoCommand.mergeWith</a>（ ）在最近执行的命令。如果<a href="qundocommand.html#mergeWith" tppabs="http://pyqt4doc.appspot.com/qundocommand.html#mergeWith">QUndoCommand.mergeWith</a>（ ）返回True ，<i>cmd</i>被删除。</p>
<p>在所有其他情况下，<i>cmd</i>简直是压入堆栈。</p>
<p>如果命令之前被撤销<i>cmd</i>被按下时，电流指令和它上面的所有命令都被删除。故<i>cmd</i>总是最终被堆栈中的最顶层。</p>
<p>一旦命令被按下时，堆栈采用它的所有权。有没有getter方法​​返回的命令，因为它修改它已经被执行后，将几乎总是导致文档的状态的腐败。</p>
<p><b>See also</b> <a href="qundocommand.html#id" tppabs="http://pyqt4doc.appspot.com/qundocommand.html#id">QUndoCommand.id</a>（）和<a href="qundocommand.html#mergeWith" tppabs="http://pyqt4doc.appspot.com/qundocommand.html#mergeWith">QUndoCommand.mergeWith</a>（ ） 。</p>


<h3 class="fn">
<a name="redo"></a>QUndoStack.redo (<i>self</i>)</h3>
<p>这种方法也是一个Qt槽与C + +的签名<tt>void redo()</tt>。</p>
<p>通过调用重做当前命令<a href="qundocommand.html#redo" tppabs="http://pyqt4doc.appspot.com/qundocommand.html#redo">QUndoCommand.redo</a>（ ） 。增加当前命令索引。</p>
<p>如果堆栈为空，或者如果堆栈顶部的命令已经被重做，这个函数不执行任何操作。</p>
<p><b>See also</b> <a href="qundostack.html#undo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undo">undo</a>（）和<a href="qundostack.html#index" tppabs="http://pyqt4doc.appspot.com/qundostack.html#index">index</a>（ ） 。</p>


<h3 class="fn">
<a name="redoText"></a>QString QUndoStack.redoText (<i>self</i>)</h3>
<p>返回的命令，将在下一呼叫重做文本<a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a>（ ） 。</p>
<p><b>See also</b> <a href="qundocommand.html#actionText" tppabs="http://pyqt4doc.appspot.com/qundocommand.html#actionText">QUndoCommand.actionText</a>（）和<a href="qundostack.html#undoText" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undoText">undoText</a>（ ） 。</p>


<h3 class="fn">
<a name="setActive"></a>QUndoStack.setActive (<i>self</i>, bool <i>active</i> = True)</h3>
<p>这种方法也是一个Qt槽与C + +的签名<tt>void setActive(bool = 1)</tt>。</p>
<h3 class="fn">
<a name="setClean"></a>QUndoStack.setClean (<i>self</i>)</h3>
<p>这种方法也是一个Qt槽与C + +的签名<tt>void setClean()</tt>。</p>
<p>标记堆栈干净并发出<a href="qundostack.html#cleanChanged" tppabs="http://pyqt4doc.appspot.com/qundostack.html#cleanChanged">cleanChanged</a>（）如果堆栈是不是已经干净了。</p>
<p>每当通过使用撤销/的堆栈恢复到这个状态重做命令，它发出的信号<a href="qundostack.html#cleanChanged" tppabs="http://pyqt4doc.appspot.com/qundostack.html#cleanChanged">cleanChanged</a>（ ） 。当堆栈离开干净的状态，这个信号被发射也。</p>
<p><b>See also</b> <a href="qundostack.html#isClean" tppabs="http://pyqt4doc.appspot.com/qundostack.html#isClean">isClean</a>（）和<a href="qundostack.html#cleanIndex" tppabs="http://pyqt4doc.appspot.com/qundostack.html#cleanIndex">cleanIndex</a>（ ） 。</p>


<h3 class="fn">
<a name="setIndex"></a>QUndoStack.setIndex (<i>self</i>, int <i>idx</i>)</h3>
<p>这种方法也是一个Qt槽与C + +的签名<tt>void setIndex(int)</tt>。</p>
<p>反复调用<a href="qundostack.html#undo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undo">undo</a>（）或<a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a>（ ），直到当前命令指数达到<i>idx</i>。此功能可用于滚动文档的状态向前向后。<a href="qundostack.html#indexChanged" tppabs="http://pyqt4doc.appspot.com/qundostack.html#indexChanged">indexChanged</a>（）被发射一次。</p>
<p><b>See also</b> <a href="qundostack.html#index" tppabs="http://pyqt4doc.appspot.com/qundostack.html#index">index</a>（ ）<a href="qundostack.html#count" tppabs="http://pyqt4doc.appspot.com/qundostack.html#count">count</a>（ ）<a href="qundostack.html#undo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undo">undo</a>（）和<a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a>（ ） 。</p>


<h3 class="fn">
<a name="setUndoLimit"></a>QUndoStack.setUndoLimit (<i>self</i>, int <i>limit</i>)</h3>
<h3 class="fn">
<a name="text"></a>QString QUndoStack.text (<i>self</i>, int <i>idx</i>)</h3>
<p>在索引返回的命令的文本<i>idx</i>。</p>
<p><b>See also</b> <a href="qundostack.html#beginMacro" tppabs="http://pyqt4doc.appspot.com/qundostack.html#beginMacro">beginMacro</a>（ ） 。</p>


<h3 class="fn">
<a name="undo"></a>QUndoStack.undo (<i>self</i>)</h3>
<p>这种方法也是一个Qt槽与C + +的签名<tt>void undo()</tt>。</p>
<p>通过调用撤消当前命令下面的命令<a href="qundocommand.html#undo" tppabs="http://pyqt4doc.appspot.com/qundocommand.html#undo">QUndoCommand.undo</a>（ ） 。减少当前命令索引。</p>
<p>如果堆栈是空的，或者如果堆栈底部的命令已被撤销，该函数不起作用。</p>
<p><b>See also</b> <a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a>（）和<a href="qundostack.html#index" tppabs="http://pyqt4doc.appspot.com/qundostack.html#index">index</a>（ ） 。</p>


<h3 class="fn">
<a name="undoLimit"></a>int QUndoStack.undoLimit (<i>self</i>)</h3>
<h3 class="fn">
<a name="undoText"></a>QString QUndoStack.undoText (<i>self</i>)</h3>
<p>返回的命令，将在下一呼叫撤消文本<a href="qundostack.html#undo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undo">undo</a>（ ） 。</p>
<p><b>See also</b> <a href="qundocommand.html#actionText" tppabs="http://pyqt4doc.appspot.com/qundocommand.html#actionText">QUndoCommand.actionText</a>（）和<a href="qundostack.html#redoText" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redoText">redoText</a>（ ） 。</p>


<h3 class="fn">
<a name="__len__"></a> QUndoStack.__len__ (<i>self</i>)</h3>
<hr>
<h2>Qt Signal Documentation</h2>
<h3 class="fn">
<a name="canRedoChanged"></a>void canRedoChanged (bool)</h3>
<p>这是该信号的默认超载。</p>
<p>这个信号被发射时的值<a href="qundostack.html#canRedo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#canRedo">canRedo</a>（）的变化。它是用来启用或禁用通过返回重做动作<a href="qundostack.html#createRedoAction" tppabs="http://pyqt4doc.appspot.com/qundostack.html#createRedoAction">createRedoAction</a>（ ） 。<i>canRedo</i>指定的新值。</p>


<h3 class="fn">
<a name="canUndoChanged"></a>void canUndoChanged (bool)</h3>
<p>这是该信号的默认超载。</p>
<p>这个信号被发射时的值<a href="qundostack.html#canUndo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#canUndo">canUndo</a>（）的变化。它是用来启用或禁用通过返回的撤消操作<a href="qundostack.html#createUndoAction" tppabs="http://pyqt4doc.appspot.com/qundostack.html#createUndoAction">createUndoAction</a>（ ） 。<i>canUndo</i>指定的新值。</p>


<h3 class="fn">
<a name="cleanChanged"></a>void cleanChanged (bool)</h3>
<p>这是该信号的默认超载。</p>
<p>每当堆栈进入或离开干净的状态这个信号被发射。如果<i>clean</i>诚然，堆栈是在一个干净的状态，否则这个信号表明，它已经离开了干净的状态。</p>
<p><b>See also</b> <a href="qundostack.html#isClean" tppabs="http://pyqt4doc.appspot.com/qundostack.html#isClean">isClean</a>（）和<a href="qundostack.html#setClean" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setClean">setClean</a>（ ） 。</p>


<h3 class="fn">
<a name="indexChanged"></a>void indexChanged (int)</h3>
<p>这是该信号的默认超载。</p>
<p>这个信号被发射时的命令修改文档的状态。这发生在一个命令撤消或重做。当一个宏命令撤消或重做，或<a href="qundostack.html#setIndex" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setIndex">setIndex</a>（）被调用时，这个信号被发射一次。</p>
<p><i>idx</i>指定当前命令，即索引。这将是到下一个调用执行的命令<a href="qundostack.html#redo" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redo">redo</a>（ ） 。</p>
<p><b>See also</b> <a href="qundostack.html#index" tppabs="http://pyqt4doc.appspot.com/qundostack.html#index">index</a>（）和<a href="qundostack.html#setIndex" tppabs="http://pyqt4doc.appspot.com/qundostack.html#setIndex">setIndex</a>（ ） 。</p>


<h3 class="fn">
<a name="redoTextChanged"></a>void redoTextChanged (const QString&amp;)</h3>
<p>这是该信号的默认超载。</p>
<p>这个信号被发射时的值<a href="qundostack.html#redoText" tppabs="http://pyqt4doc.appspot.com/qundostack.html#redoText">redoText</a>（）的变化。它是用来更新由返回重做动作的text属性<a href="qundostack.html#createRedoAction" tppabs="http://pyqt4doc.appspot.com/qundostack.html#createRedoAction">createRedoAction</a>（ ） 。<i>redoText</i>指定新文本。</p>


<h3 class="fn">
<a name="undoTextChanged"></a>void undoTextChanged (const QString&amp;)</h3>
<p>这是该信号的默认超载。</p>
<p>这个信号被发射时的值<a href="qundostack.html#undoText" tppabs="http://pyqt4doc.appspot.com/qundostack.html#undoText">undoText</a>（）的变化。它是用来更新返回的撤消操作的text属性<a href="qundostack.html#createUndoAction" tppabs="http://pyqt4doc.appspot.com/qundostack.html#createUndoAction">createUndoAction</a>（ ） 。<i>undoText</i>指定新文本。</p>
<address>
<div class="ad">
<br> 
<br><hr>
</div>
<div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address">
<td align="left" width="25%">PyQt 4.10.3 for X11</td>
<td align="center" width="50%">Copyright © <a href="http://www.riverbankcomputing.com/">Riverbank Computing Ltd</a> and <a href="http://www.qtsoftware.com/">Nokia</a> 2012</td>
<td align="right" width="25%">Qt 4.8.5</td>
</tr></table></div>
</address>
</body>
</html>