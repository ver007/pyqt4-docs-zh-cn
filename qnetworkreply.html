<html>
<head>
<title>QNetworkReply Class Reference</title>
<style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr></tr>
<td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" tppabs="http://pyqt4doc.appspot.com/images/rb-logo.png" width="32"></td>
<td width="1">  </td>
<td class="postheader" valign="center">
<a href="index.html" tppabs="http://pyqt4doc.appspot.com/index.html"><font color="#004faf">Home</font></a> · <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/classes.html"><font color="#004faf">All Classes</font></a> · <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/modules.html"><font color="#004faf">Modules</font></a>  · <a href="qss.html"><font color="#004faf">QSS HELP</font></a>  · <a href="qtqss.html"><font color="#004faf">QSS 案例</font></a> · <a href="HTTP://VER007.COM"><font color="#004faf">VER007 HOME</font></a> 
</td>
</table>
<h1 align="center">QNetworkReply Class Reference<br><sup><sup>[<a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qtnetwork.html">QtNetwork</a> module]</sup></sup>
</h1>
<p>该QNetworkReply类包含数据和标头与发送请求<a href="qnetworkaccessmanager.html" tppabs="http://pyqt4doc.appspot.com/qnetworkaccessmanager.html">QNetworkAccessManager</a> <a href="#details">More...</a></p>

<p>继承<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>。</p>
<h3>Types</h3>
<ul><li>
<div class="fn"></div>enum <b><a href="qnetworkreply.html#NetworkError-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#NetworkError-enum">NetworkError</a></b> { NoError, ConnectionRefusedError, RemoteHostClosedError, HostNotFoundError, ..., TemporaryNetworkFailureError }</li></ul>
<h3>Methods</h3>
<ul>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#QNetworkReply" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#QNetworkReply">__init__</a></b> (<i>self</i>, QObject <i>parent</i> = None)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#abort" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#abort">abort</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QVariant <b><a href="qnetworkreply.html#attribute" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#attribute">attribute</a></b> (<i>self</i>, QNetworkRequest.Attribute <i>code</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#close" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#close">close</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>NetworkError <b><a href="qnetworkreply.html#error" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#error">error</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qnetworkreply.html#hasRawHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#hasRawHeader">hasRawHeader</a></b> (<i>self</i>, QByteArray <i>headerName</i>)</li>
<li>
<div class="fn"></div>QVariant <b><a href="qnetworkreply.html#header" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#header">header</a></b> (<i>self</i>, QNetworkRequest.KnownHeaders <i>header</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#ignoreSslErrors" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#ignoreSslErrors-2" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#ignoreSslErrors-2">ignoreSslErrors</a></b> (<i>self</i>, list-of-QSslError <i>errors</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qnetworkreply.html#isFinished" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#isFinished">isFinished</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qnetworkreply.html#isRunning" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#isRunning">isRunning</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qnetworkreply.html#isSequential" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#isSequential">isSequential</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QNetworkAccessManager <b><a href="qnetworkreply.html#manager" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#manager">manager</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QNetworkAccessManager.Operation <b><a href="qnetworkreply.html#operation" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#operation">operation</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QByteArray <b><a href="qnetworkreply.html#rawHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#rawHeader">rawHeader</a></b> (<i>self</i>, QByteArray <i>headerName</i>)</li>
<li>
<div class="fn"></div>list-of-QByteArray <b><a href="qnetworkreply.html#rawHeaderList" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#rawHeaderList">rawHeaderList</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>list-of-tuple-of-QByteArray-QByteArray <b><a href="qnetworkreply.html#rawHeaderPairs" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#rawHeaderPairs">rawHeaderPairs</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qnetworkreply.html#readBufferSize" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#readBufferSize">readBufferSize</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QNetworkRequest <b><a href="qnetworkreply.html#request" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#request">request</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#setAttribute" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setAttribute">setAttribute</a></b> (<i>self</i>, QNetworkRequest.Attribute <i>code</i>, QVariant <i>value</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#setError" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setError">setError</a></b> (<i>self</i>, NetworkError <i>errorCode</i>, QString <i>errorString</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#setFinished" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setFinished">setFinished</a></b> (<i>self</i>, bool <i>finished</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#setHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setHeader">setHeader</a></b> (<i>self</i>, QNetworkRequest.KnownHeaders <i>header</i>, QVariant <i>value</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#setOperation" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setOperation">setOperation</a></b> (<i>self</i>, QNetworkAccessManager.Operation <i>operation</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#setRawHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setRawHeader">setRawHeader</a></b> (<i>self</i>, QByteArray <i>headerName</i>, QByteArray <i>value</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#setReadBufferSize" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setReadBufferSize">setReadBufferSize</a></b> (<i>self</i>, int <i>size</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#setRequest" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setRequest">setRequest</a></b> (<i>self</i>, QNetworkRequest <i>request</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#setSslConfiguration" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setSslConfiguration">setSslConfiguration</a></b> (<i>self</i>, QSslConfiguration <i>configuration</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qnetworkreply.html#setUrl" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setUrl">setUrl</a></b> (<i>self</i>, QUrl <i>url</i>)</li>
<li>
<div class="fn"></div>QSslConfiguration <b><a href="qnetworkreply.html#sslConfiguration" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#sslConfiguration">sslConfiguration</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QUrl <b><a href="qnetworkreply.html#url" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#url">url</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qnetworkreply.html#writeData" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#writeData">writeData</a></b> (<i>self</i>, str <i>data</i>)</li>
</ul>
<h3>Qt Signals</h3>
<ul>
<li>
<div class="fn"></div>void <b><a href="qnetworkreply.html#downloadProgress" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#downloadProgress">downloadProgress</a></b> (qint64,qint64)</li>
<li>
<div class="fn"></div>void <b><a href="qnetworkreply.html#error-2" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#error-2">error</a></b> (QNetworkReply::NetworkError)</li>
<li>
<div class="fn"></div>void <b><a href="qnetworkreply.html#finished" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#finished">finished</a></b> ()</li>
<li>
<div class="fn"></div>void <b><a href="qnetworkreply.html#metaDataChanged" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#metaDataChanged">metaDataChanged</a></b> ()</li>
<li>
<div class="fn"></div>void <b><a href="qnetworkreply.html#sslErrors" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#sslErrors">sslErrors</a></b> (const QList&lt;QSslError&gt;&amp;)</li>
<li>
<div class="fn"></div>void <b><a href="qnetworkreply.html#uploadProgress" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#uploadProgress">uploadProgress</a></b> (qint64,qint64)</li>
</ul>
<a name="details"></a><div class="ad">
<hr>
 
</div>
<h2>Detailed Description</h2>
<p>该QNetworkReply类包含数据和标头与发送请求<a href="qnetworkaccessmanager.html" tppabs="http://pyqt4doc.appspot.com/qnetworkaccessmanager.html">QNetworkAccessManager</a></p>
<p>该QNetworkReply类包含与贴有一个请求中的数据和元数据<a href="qnetworkaccessmanager.html" tppabs="http://pyqt4doc.appspot.com/qnetworkaccessmanager.html">QNetworkAccessManager</a>。喜欢<a href="qnetworkrequest.html" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html">QNetworkRequest</a>，它包含一个URL和标题（无论是在解析和原始形式） ，对答复的状态和回复本身的内容的一些信息。</p>
<p>QNetworkReply是顺序存取<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>，这意味着，一旦数据从对象读取时，它不再保持通过该装置。因此，它是应用程序的责任，保持这个数据，如果需要。每当更多的数据是从网络接收和处理，则<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（）信号被发射。</p>
<p>该<a href="qnetworkreply.html#downloadProgress" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#downloadProgress">downloadProgress</a>（）信号也被发射的数据的接收时，但包含在它的字节数可能并不代表实际收到的字节，如果有的话变换完成的内容（例如，解压缩并去除协议开销）。</p>
<p>尽管QNetworkReply是<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>连接到应答的内容，它也发射<a href="qnetworkreply.html#uploadProgress" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#uploadProgress">uploadProgress</a>（）信号，其指示上载于具有这样的内容的操作的进度。</p>
<p><b>Note:</b>请不要删除该对象在连接到插槽<a href="qnetworkreply.html#error" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#error">error</a>（）或<a href="qnetworkreply.html#finished" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#finished">finished</a>（）信号。使用<a href="qobject.html#deleteLater" tppabs="http://pyqt4doc.appspot.com/qobject.html#deleteLater">deleteLater</a>（ ） 。</p>
<hr>
<h2>Type Documentation</h2>
<h3 class="fn">
<a name="NetworkError-enum"></a>QNetworkReply.NetworkError</h3>
<p>指示请求的处理过程中找到的所有可能的错误条件。</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QNetworkReply.NoError</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">没有错误条件。<b>Note:</b>当HTTP协议返回一个重定向没有错误将被报告。您可以检查是否有与重定向<a href="qnetworkrequest.html#Attribute-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html#Attribute-enum">QNetworkRequest.RedirectionTargetAttribute</a>属性。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ConnectionRefusedError</tt>
</td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">远程服务器拒绝连接（服务器不接受请求）</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.RemoteHostClosedError</tt>
</td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">远程服务器关闭了连接过早，整个答复接收和处理前</td>
</tr>
<tr>
<td class="topAlign"><tt>QNetworkReply.HostNotFoundError</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">远程主机名未找到（无效主机名）</td>
</tr>
<tr>
<td class="topAlign"><tt>QNetworkReply.TimeoutError</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">连接到远程服务器超时</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.OperationCanceledError</tt>
</td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">该操作是通过调用取消<a href="qnetworkreply.html#abort" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#abort">abort</a>（）或<a href="qnetworkreply.html#close" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#close">close</a>（ ），它被完成之前。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.SslHandshakeFailedError</tt>
</td>
<td class="topAlign"><tt>6</tt></td>
<td class="topAlign">在SSL / TLS握手失败，加密的通道不能成立。该<a href="qnetworkreply.html#sslErrors" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#sslErrors">sslErrors</a>（）信号应该被发射。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.TemporaryNetworkFailureError</tt>
</td>
<td class="topAlign"><tt>7</tt></td>
<td class="topAlign">该连接由于从网络断开断裂，但是在系统启动漫游到另一个接入点。该请求应该被重新提交，并会尽快连接重新建立处理。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ProxyConnectionRefusedError</tt>
</td>
<td class="topAlign"><tt>101</tt></td>
<td class="topAlign">连接到代理服务器被拒绝（代理服务器不接受请求）</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ProxyConnectionClosedError</tt>
</td>
<td class="topAlign"><tt>102</tt></td>
<td class="topAlign">代理服务器关闭了连接过早，整个答复接收和处理前</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ProxyNotFoundError</tt>
</td>
<td class="topAlign"><tt>103</tt></td>
<td class="topAlign">代理主机名没有被发现（无效的代理主机名）</td>
</tr>
<tr>
<td class="topAlign"><tt>QNetworkReply.ProxyTimeoutError</tt></td>
<td class="topAlign"><tt>104</tt></td>
<td class="topAlign">连接到代理服务器超时或代理没有及时发送请求回复</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ProxyAuthenticationRequiredError</tt>
</td>
<td class="topAlign"><tt>105</tt></td>
<td class="topAlign">代理需要身份验证才能兑现的要求，但没有接受其提供的任何凭证（如有）</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ContentAccessDenied</tt>
</td>
<td class="topAlign"><tt>201</tt></td>
<td class="topAlign">在访问远程内容被拒绝（类似于HTTP错误401 ）</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ContentOperationNotPermittedError</tt>
</td>
<td class="topAlign"><tt>202</tt></td>
<td class="topAlign">要求对远程内容的操作是不允许的</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ContentNotFoundError</tt>
</td>
<td class="topAlign"><tt>203</tt></td>
<td class="topAlign">远程内容并没有在服务器上找到（类似于HTTP错误404 ）</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.AuthenticationRequiredError</tt>
</td>
<td class="topAlign"><tt>204</tt></td>
<td class="topAlign">远程服务器要求身份验证服务的内容，但提供的凭据不被接受（如果有的话）</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ContentReSendError</tt>
</td>
<td class="topAlign"><tt>205</tt></td>
<td class="topAlign">请求需要再次发送，但这种失败的例子，因为上传的数据无法读取第二次。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ProtocolUnknownError</tt>
</td>
<td class="topAlign"><tt>301</tt></td>
<td class="topAlign">网络访问API无法兑现的请求，因为该协议是不为人所知的</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.ProtocolInvalidOperationError</tt>
</td>
<td class="topAlign"><tt>302</tt></td>
<td class="topAlign">所请求的操作是此协议无效</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.UnknownNetworkError</tt>
</td>
<td class="topAlign"><tt>99</tt></td>
<td class="topAlign">检测到一个未知的网络有关的错误</td>
</tr>
<tr>
<td class="topAlign"><tt>QNetworkReply.UnknownProxyError</tt></td>
<td class="topAlign"><tt>199</tt></td>
<td class="topAlign">检测到一个未知的代理相关的错误</td>
</tr>
<tr>
<td class="topAlign">
<tt>QNetworkReply.UnknownContentError</tt>
</td>
<td class="topAlign"><tt>299</tt></td>
<td class="topAlign">检测到一个未知错误相关的远程内容</td>
</tr>
<tr>
<td class="topAlign"><tt>QNetworkReply.ProtocolFailure</tt></td>
<td class="topAlign"><tt>399</tt></td>
<td class="topAlign">检测在协议的故障（解析错误，无效的或意外的反应，等等）</td>
</tr>
</table>
<p><b>See also</b> <a href="qnetworkreply.html#error" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#error">error</a>（ ） 。</p>


<hr>
<h2>Method Documentation</h2>
<h3 class="fn">
<a name="QNetworkReply"></a>QNetworkReply.__init__ (<i>self</i>, <a href="qobject.html" tppabs="http://pyqt4doc.appspot.com/qobject.html">QObject</a> <i>parent</i> = None)</h3>
<p>该<i>parent</i>的说法，如果不是没有，原因<i>self</i>通过Qt的，而不是PyQt的拥有。</p>
<p>创建<a href="qnetworkreply.html" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html">QNetworkReply</a>与父对象<i>parent</i>。</p>
<p>你不能直接实例化<a href="qnetworkreply.html" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html">QNetworkReply</a>对象。使用<a href="qnetworkaccessmanager.html" tppabs="http://pyqt4doc.appspot.com/qnetworkaccessmanager.html">QNetworkAccessManager</a>函数来做到这一点。</p>


<h3 class="fn">
<a name="abort"></a>QNetworkReply.abort (<i>self</i>)</h3>
<p>这种方法是抽象的，应在任何子类中重新实现。</p>
<p>立即中止操作，并关闭所有的网络连接仍然处于打开状态。上传仍在进行中，也中止。</p>
<p><b>See also</b> <a href="qnetworkreply.html#close" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#close">close</a>（ ） 。</p>


<h3 class="fn">
<a name="attribute"></a>QVariant QNetworkReply.attribute (<i>self</i>, <a href="qnetworkrequest.html#Attribute-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html#Attribute-enum">QNetworkRequest.Attribute</a> <i>code</i>)</h3>
<h3 class="fn">
<a name="close"></a>QNetworkReply.close (<i>self</i>)</h3>
<p>从重新实现<a href="qiodevice.html#close" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#close">QIODevice.close</a>（ ） 。</p>
<p>关闭此设备以供读取。未读取的数据将被丢弃，但是网络资源不被丢弃，直到它们被完成。特别是，如果任何的上传过程中，它会继续，直到它完成。</p>
<p>该<a href="qnetworkreply.html#finished" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#finished">finished</a>当所有的操作都​​在和网络资源被释放（ ）信号被发射。</p>
<p><b>See also</b> <a href="qnetworkreply.html#abort" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#abort">abort</a>（）和<a href="qnetworkreply.html#finished" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#finished">finished</a>（ ） 。</p>


<h3 class="fn">
<a name="error"></a><a href="qnetworkreply.html#NetworkError-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#NetworkError-enum">NetworkError</a> QNetworkReply.error (<i>self</i>)</h3>
<p>返回该请求的处理过程中发现错误。如果没有发现错误，返回<a href="qnetworkreply.html#NetworkError-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#NetworkError-enum">NoError</a>。</p>
<p><b>See also</b> <a href="qnetworkreply.html#setError" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setError">setError</a>（ ） 。</p>


<h3 class="fn">
<a name="hasRawHeader"></a>bool QNetworkReply.hasRawHeader (<i>self</i>, <a href="qbytearray.html" tppabs="http://pyqt4doc.appspot.com/qbytearray.html">QByteArray</a> <i>headerName</i>)</h3>
<p>返回True如果name原始标题<i>headerName</i>被送往由远程服务器</p>
<p><b>See also</b> <a href="qnetworkreply.html#rawHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#rawHeader">rawHeader</a>（ ） 。</p>


<h3 class="fn">
<a name="header"></a>QVariant QNetworkReply.header (<i>self</i>, <a href="qnetworkrequest.html#KnownHeaders-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html#KnownHeaders-enum">QNetworkRequest.KnownHeaders</a> <i>header</i>)</h3>
<p>返回已知的标头的值<i>header</i>，如果这头被送往由远程服务器。如果头没有被发送，返回无效<a href="qvariant.html" tppabs="http://pyqt4doc.appspot.com/qvariant.html">QVariant</a>。</p>
<p><b>See also</b> <a href="qnetworkreply.html#rawHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#rawHeader">rawHeader</a>（ ）<a href="qnetworkreply.html#setHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setHeader">setHeader</a>（）和<a href="qnetworkrequest.html#header" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html#header">QNetworkRequest.header</a>（ ） 。</p>


<h3 class="fn">
<a name="ignoreSslErrors"></a>QNetworkReply.ignoreSslErrors (<i>self</i>)</h3>
<p>这种方法也是一个Qt槽与C + +的签名<tt>void ignoreSslErrors()</tt>。</p>
<p>如果这个函数被调用，涉及到网络连接的SSL错误将被忽略，包括证书验证错误。</p>
<p><b>Warning:</b>一定要始终让用户检查报告的错误<a href="qnetworkreply.html#sslErrors" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#sslErrors">sslErrors</a>（ ）信号，并且只从用户的程序是确定经确认后，调用此方法。如果有意外的错误，得到的答复应中止。不检查实际的错误调用此方法将最有可能带来安全风险的应用程序。使用它以极大的关怀！</p>
<p>这个函数可以从连接到插槽被称为<a href="qnetworkreply.html#sslErrors" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#sslErrors">sslErrors</a>（）信号，这表明它被发现的错误。</p>
<p><b>See also</b> <a href="qnetworkreply.html#sslConfiguration" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#sslConfiguration">sslConfiguration</a>（ ）<a href="qnetworkreply.html#sslErrors" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#sslErrors">sslErrors</a>（）和<a href="qsslsocket.html#ignoreSslErrors" tppabs="http://pyqt4doc.appspot.com/qsslsocket.html#ignoreSslErrors">QSslSocket.ignoreSslErrors</a>（ ） 。</p>


<h3 class="fn">
<a name="ignoreSslErrors-2"></a>QNetworkReply.ignoreSslErrors (<i>self</i>, list-of-QSslError <i>errors</i>)</h3>
<p>这是一个重载函数。</p>
<p>如果这个函数被调用时，在给定的SSL错误<i>errors</i>将被忽略。</p>
<p>请注意，您可以在SSL错误设定预期的证书：如果，例如，你想发出一个请求到使用自签名证书的服务器时，请考虑下面的代码片断：</p>
<pre class="cpp">
 <span class="type"><a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qsslcertificate.html" tppabs="http://pyqt4doc.appspot.com/qsslcertificate.html">QSslCertificate</a></span><span class="operator">&gt;</span> cert <span class="operator">=</span> <span class="type"><a href="qsslcertificate.html" tppabs="http://pyqt4doc.appspot.com/qsslcertificate.html">QSslCertificate</a></span><span class="operator">.</span>fromPath(QLatin1String(<span class="string">"server-certificate.pem"</span>));
 <span class="type"><a href="qsslerror.html" tppabs="http://pyqt4doc.appspot.com/qsslerror.html">QSslError</a></span> <a href="qnetworkreply.html#error" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#error">error</a>(<span class="type"><a href="qsslerror.html" tppabs="http://pyqt4doc.appspot.com/qsslerror.html">QSslError</a></span><span class="operator">.</span>SelfSignedCertificate<span class="operator">,</span> cert<span class="operator">.</span>at(<span class="number">0</span>));
 <span class="type"><a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="qsslerror.html" tppabs="http://pyqt4doc.appspot.com/qsslerror.html">QSslError</a></span><span class="operator">&gt;</span> expectedSslErrors;
 expectedSslErrors<span class="operator">.</span>append(error);

 <span class="type"><a href="qnetworkreply.html" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html">QNetworkReply</a></span> <span class="operator">*</span>reply <span class="operator">=</span> manager<span class="operator">.</span>get(<span class="type"><a href="qnetworkrequest.html" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html">QNetworkRequest</a></span>(<span class="type"><a href="qurl.html" tppabs="http://pyqt4doc.appspot.com/qurl.html">QUrl</a></span>(<span class="string">"https://server.tld/index.html"</span>)));
 reply<span class="operator">-</span><span class="operator">&gt;</span><a href="qnetworkreply.html#ignoreSslErrors" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>(expectedSslErrors);
 <span class="comment">// here connect signals etc.</span>
</pre>
<p>多次调用该函数会被替换传入以前调用的错误列表。您可以清除通过调用这个函数以一个空列表，你要忽略错误的列表。</p>
<p>此功能被引入Qt的4.6 。</p>
<p><b>See also</b> <a href="qnetworkreply.html#sslConfiguration" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#sslConfiguration">sslConfiguration</a>（ ）<a href="qnetworkreply.html#sslErrors" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#sslErrors">sslErrors</a>（）和<a href="qsslsocket.html#ignoreSslErrors" tppabs="http://pyqt4doc.appspot.com/qsslsocket.html#ignoreSslErrors">QSslSocket.ignoreSslErrors</a>（ ） 。</p>


<h3 class="fn">
<a name="isFinished"></a>bool QNetworkReply.isFinished (<i>self</i>)</h3>
<p>返回True时，答复已完成或已中止。</p>
<p>此功能被引入Qt的4.6 。</p>
<p><b>See also</b> <a href="qnetworkreply.html#isRunning" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#isRunning">isRunning</a>（ ） 。</p>


<h3 class="fn">
<a name="isRunning"></a>bool QNetworkReply.isRunning (<i>self</i>)</h3>
<p>返回True时，该请求仍在处理并答复未能完成或已中止呢。</p>
<p>此功能被引入Qt的4.6 。</p>
<p><b>See also</b> <a href="qnetworkreply.html#isFinished" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#isFinished">isFinished</a>（ ） 。</p>


<h3 class="fn">
<a name="isSequential"></a>bool QNetworkReply.isSequential (<i>self</i>)</h3>
<h3 class="fn">
<a name="manager"></a><a href="qnetworkaccessmanager.html" tppabs="http://pyqt4doc.appspot.com/qnetworkaccessmanager.html">QNetworkAccessManager</a> QNetworkReply.manager (<i>self</i>)</h3>
<p>返回<a href="qnetworkaccessmanager.html" tppabs="http://pyqt4doc.appspot.com/qnetworkaccessmanager.html">QNetworkAccessManager</a>这是用于创建此<a href="qnetworkreply.html" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html">QNetworkReply</a>对象。起初，它也是父对象。</p>


<h3 class="fn">
<a name="operation"></a><a href="qnetworkaccessmanager.html#Operation-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkaccessmanager.html#Operation-enum">QNetworkAccessManager.Operation</a> QNetworkReply.operation (<i>self</i>)</h3>
<p>返回被张贴该回复操作。</p>
<p><b>See also</b> <a href="qnetworkreply.html#setOperation" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setOperation">setOperation</a>（ ） 。</p>


<h3 class="fn">
<a name="rawHeader"></a><a href="qbytearray.html" tppabs="http://pyqt4doc.appspot.com/qbytearray.html">QByteArray</a> QNetworkReply.rawHeader (<i>self</i>, <a href="qbytearray.html" tppabs="http://pyqt4doc.appspot.com/qbytearray.html">QByteArray</a> <i>headerName</i>)</h3>
<p>返回头的原始内容<i>headerName</i>由远程服务器发送。如果没有这样的标题，则返回一个空字节数组，这可能是从一个空的头没有区别。使用<a href="qnetworkreply.html#hasRawHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#hasRawHeader">hasRawHeader</a>（）来验证，如果服务器发送这样的头字段。</p>
<p><b>See also</b> <a href="qnetworkreply.html#setRawHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setRawHeader">setRawHeader</a>（ ）<a href="qnetworkreply.html#hasRawHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#hasRawHeader">hasRawHeader</a>（）和<a href="qnetworkreply.html#header" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#header">header</a>（ ） 。</p>


<h3 class="fn">
<a name="rawHeaderList"></a>list-of-QByteArray QNetworkReply.rawHeaderList (<i>self</i>)</h3>
<p>返回由远程服务器发送的，因为它们被发送的顺序头字段的列表。重复的头被合并在一起并发生后重复的。</p>


<h3 class="fn">
<a name="rawHeaderPairs"></a>list-of-tuple-of-QByteArray-QByteArray QNetworkReply.rawHeaderPairs (<i>self</i>)</h3>
<p>返回原头对的列表。</p>


<h3 class="fn">
<a name="readBufferSize"></a>int QNetworkReply.readBufferSize (<i>self</i>)</h3>
<p>返回读缓冲区的大小，以字节为单位。</p>
<p><b>See also</b> <a href="qnetworkreply.html#setReadBufferSize" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setReadBufferSize">setReadBufferSize</a>（ ） 。</p>


<h3 class="fn">
<a name="request"></a><a href="qnetworkrequest.html" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html">QNetworkRequest</a> QNetworkReply.request (<i>self</i>)</h3>
<p>返回被张贴于本答复的请求。在特殊的，注意的URL请求可以是比该答复的不同。</p>
<p><b>See also</b> <a href="qnetworkrequest.html#url" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html#url">QNetworkRequest.url</a>（ ）<a href="qnetworkreply.html#url" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#url">url</a>（）和<a href="qnetworkreply.html#setRequest" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setRequest">setRequest</a>（ ） 。</p>


<h3 class="fn">
<a name="setAttribute"></a>QNetworkReply.setAttribute (<i>self</i>, <a href="qnetworkrequest.html#Attribute-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html#Attribute-enum">QNetworkRequest.Attribute</a> <i>code</i>, QVariant <i>value</i>)</h3>
<p>设置属性<i>code</i>有值<i>value</i>。如果<i>code</i>以前设置，它会被复盖。如果<i>value</i>是无效的<a href="qvariant.html" tppabs="http://pyqt4doc.appspot.com/qvariant.html">QVariant</a>，该属性将取消。</p>
<p><b>See also</b> <a href="qnetworkreply.html#attributex" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#attributex">attribute</a>（）和<a href="qnetworkrequest.html#setAttribute" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html#setAttribute">QNetworkRequest.setAttribute</a>（ ） 。</p>


<h3 class="fn">
<a name="setError"></a>QNetworkReply.setError (<i>self</i>, <a href="qnetworkreply.html#NetworkError-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#NetworkError-enum">NetworkError</a> <i>errorCode</i>, QString <i>errorString</i>)</h3>
<p>设置错误条件是<i>errorCode</i>。人类可读的消息设置<i>errorString</i>。</p>
<p>调用SETERROR （ ）不会发出错误（<a href="qnetworkreply.html#NetworkError-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#NetworkError-enum">QNetworkReply.NetworkError</a>）信号。</p>
<p><b>See also</b> <a href="qnetworkreply.html#error" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#error">error</a>（）和<a href="qiodevice.html#errorString" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#errorString">errorString</a>（ ） 。</p>


<h3 class="fn">
<a name="setFinished"></a>QNetworkReply.setFinished (<i>self</i>, bool <i>finished</i>)</h3>
<p>设置答复<i>finished</i>。</p>
<p>有在此之后设置回复的数据不能改变。</p>
<p>此功能被引入Qt的4.8 。</p>
<p><b>See also</b> <a href="qnetworkreply.html#finished" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#finished">finished</a>（）和<a href="qnetworkreply.html#isFinished" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#isFinished">isFinished</a>（ ） 。</p>


<h3 class="fn">
<a name="setHeader"></a>QNetworkReply.setHeader (<i>self</i>, <a href="qnetworkrequest.html#KnownHeaders-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html#KnownHeaders-enum">QNetworkRequest.KnownHeaders</a> <i>header</i>, QVariant <i>value</i>)</h3>
<p>设置已知的头<i>header</i>有利用价值<i>value</i>。标题的相应的原始表格将被设置为好。</p>
<p><b>See also</b> <a href="qnetworkreply.html#header" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#header">header</a>（ ）<a href="qnetworkreply.html#setRawHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setRawHeader">setRawHeader</a>（）和<a href="qnetworkrequest.html#setHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html#setHeader">QNetworkRequest.setHeader</a>（ ） 。</p>


<h3 class="fn">
<a name="setOperation"></a>QNetworkReply.setOperation (<i>self</i>, <a href="qnetworkaccessmanager.html#Operation-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkaccessmanager.html#Operation-enum">QNetworkAccessManager.Operation</a> <i>operation</i>)</h3>
<p>设置为是此对象的相关操作<i>operation</i>。这个值将被退回<a href="qnetworkreply.html#operation" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#operation">operation</a>（ ） 。</p>
<p>注：在创建这个对象，而不是再次改变时，操作应设置。</p>
<p><b>See also</b> <a href="qnetworkreply.html#operation" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#operation">operation</a>（）和<a href="qnetworkreply.html#setRequest" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setRequest">setRequest</a>（ ） 。</p>


<h3 class="fn">
<a name="setRawHeader"></a>QNetworkReply.setRawHeader (<i>self</i>, <a href="qbytearray.html" tppabs="http://pyqt4doc.appspot.com/qbytearray.html">QByteArray</a> <i>headerName</i>, <a href="qbytearray.html" tppabs="http://pyqt4doc.appspot.com/qbytearray.html">QByteArray</a> <i>value</i>)</h3>
<p>设置原始标题<i>headerName</i>有利用价值<i>value</i>。如果<i>headerName</i>以前设置，它将被重写。具有相同名称的多个HTTP头在功能上等同于串联的值，用逗号分隔的一个单头。</p>
<p>If <i>headerName</i>匹配一个已知的头，值<i>value</i>将被解析和相应的解析形式也将被设置。</p>
<p><b>See also</b> <a href="qnetworkreply.html#rawHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#rawHeader">rawHeader</a>（ ）<a href="qnetworkreply.html#header" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#header">header</a>（ ）<a href="qnetworkreply.html#setHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setHeader">setHeader</a>（）和<a href="qnetworkrequest.html#setRawHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html#setRawHeader">QNetworkRequest.setRawHeader</a>（ ） 。</p>


<h3 class="fn">
<a name="setReadBufferSize"></a>QNetworkReply.setReadBufferSize (<i>self</i>, int <i>size</i>)</h3>
<p>设置读缓冲要的大小<i>size</i>字节。读缓冲区存放的数据正在被下载的断网，然后才读缓冲区<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">QIODevice.read</a>（ ） 。设置缓冲区大小为0，将使缓冲区无限的大小。</p>
<p><a href="qnetworkreply.html" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html">QNetworkReply</a>会试图阻止从网络读取一次该缓冲区已满（即，<a href="qiodevice.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesAvailable">bytesAvailable</a>（）返回<i>size</i>或更多） ，从而导致下载到踩下油门为好。如果缓冲区不局限于在大小，<a href="qnetworkreply.html" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html">QNetworkReply</a>会尝试从网络中尽可能快地下载。</p>
<p>不像<a href="qabstractsocket.html#setReadBufferSize" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setReadBufferSize">QAbstractSocket.setReadBufferSize</a>（ ）<a href="qnetworkreply.html" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html">QNetworkReply</a>不能在读取缓冲区大小保证精度。即，<a href="qiodevice.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesAvailable">bytesAvailable</a>（ ）可以返回多个<i>size</i>。</p>
<p><b>See also</b> <a href="qnetworkreply.html#readBufferSize" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#readBufferSize">readBufferSize</a>（ ） 。</p>


<h3 class="fn">
<a name="setRequest"></a>QNetworkReply.setRequest (<i>self</i>, <a href="qnetworkrequest.html" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html">QNetworkRequest</a> <i>request</i>)</h3>
<p>设置相关的请求此对象是<i>request</i>。这个值将被退回<a href="qnetworkreply.html#request" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#request">request</a>（ ） 。</p>
<p>注：在创建这个对象，而不是再次改变时，该请求应该被设置。</p>
<p><b>See also</b> <a href="qnetworkreply.html#request" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#request">request</a>（）和<a href="qnetworkreply.html#setOperation" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setOperation">setOperation</a>（ ） 。</p>


<h3 class="fn">
<a name="setSslConfiguration"></a>QNetworkReply.setSslConfiguration (<i>self</i>, <a href="qsslconfiguration.html" tppabs="http://pyqt4doc.appspot.com/qsslconfiguration.html">QSslConfiguration</a> <i>configuration</i>)</h3>
<p>设置与此请求关联的网络连接的SSL配置，如果可能的话，是说的<i>config</i>。</p>
<p><b>See also</b> <a href="qnetworkreply.html#sslConfiguration" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#sslConfiguration">sslConfiguration</a>（ ） 。</p>


<h3 class="fn">
<a name="setUrl"></a>QNetworkReply.setUrl (<i>self</i>, <a href="qurl.html" tppabs="http://pyqt4doc.appspot.com/qurl.html">QUrl</a> <i>url</i>)</h3>
<p>设置被加工成的网址<i>url</i>。通常，该URL匹配被张贴的请求，但对各种原因也可以是不同的（例如，被制成一个文件路径的绝对或规范） 。</p>
<p><b>See also</b> <a href="qnetworkreply.html#url" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#url">url</a>（ ）<a href="qnetworkreply.html#request" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#request">request</a>（）和<a href="qnetworkrequest.html#url" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html#url">QNetworkRequest.url</a>（ ） 。</p>


<h3 class="fn">
<a name="sslConfiguration"></a><a href="qsslconfiguration.html" tppabs="http://pyqt4doc.appspot.com/qsslconfiguration.html">QSslConfiguration</a> QNetworkReply.sslConfiguration (<i>self</i>)</h3>
<p>返回与此相关的答复，如果已使用SSL SSL配置和状态。它将包含远程服务器的证书，其证书链导致的证书颁发机构，以及在使用中的加密密码。</p>
<p>同行的证书，其证书链会的时候被称为<a href="qnetworkreply.html#sslErrors" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#sslErrors">sslErrors</a>（）被发射，如果它的发射。</p>
<p><b>See also</b> <a href="qnetworkreply.html#setSslConfiguration" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setSslConfiguration">setSslConfiguration</a>（ ） 。</p>


<h3 class="fn">
<a name="url"></a><a href="qurl.html" tppabs="http://pyqt4doc.appspot.com/qurl.html">QUrl</a> QNetworkReply.url (<i>self</i>)</h3>
<p>返回下载或上传的内容的URL 。注意，这个URL可以是从原始请求的不同。</p>
<p><b>See also</b> <a href="qnetworkreply.html#request" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#request">request</a>（ ）<a href="qnetworkreply.html#setUrl" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setUrl">setUrl</a>（）和<a href="qnetworkrequest.html#url" tppabs="http://pyqt4doc.appspot.com/qnetworkrequest.html#url">QNetworkRequest.url</a>（ ） 。</p>
<h3 class="fn">
<a name="writeData"></a>int QNetworkReply.writeData (<i>self</i>, str <i>data</i>)</h3>
<hr>
<h2>Qt Signal Documentation</h2>
<h3 class="fn">
<a name="downloadProgress"></a>void downloadProgress (qint64,qint64)</h3>
<p>这是该信号的默认超载。</p>
<p>这个信号被发射，以指示该网络请求的下载部分的进展，如果有任何。如果没有与此请求关联的下载，这个信号将被一次使用0作为发射两者的值<i>bytesReceived</i>和<i>bytesTotal</i>。</p>
<p>该<i>bytesReceived</i>参数表示接收的字节数，而<i>bytesTotal</i>表示预期要被下载的总字节数。如果不知道要被下载的字节数，<i>bytesTotal</i>将为-1 。</p>
<p>下载完成时<i>bytesReceived</i>等于<i>bytesTotal</i>。在那个时候，<i>bytesTotal</i>不会是-1。</p>
<p>注意，这两个值<i>bytesReceived</i>和<i>bytesTotal</i>可以从不同的<a href="qiodevice.html#size" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#size">size</a>（ ） ，获得通过的总字节数<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（）或<a href="qiodevice.html#readAll" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readAll">readAll</a>（） ，或标头（ ContentLengthHeader ）的值。其理由是，有可能是协议开销或数据可能在下载过程中被压缩。</p>
<p><b>See also</b> <a href="qnetworkreply.html#uploadProgress" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#uploadProgress">uploadProgress</a>（）和<a href="qiodevice.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesAvailable">bytesAvailable</a>（ ） 。</p>


<h3 class="fn">
<a name="error-2"></a>void error (QNetworkReply::NetworkError)</h3>
<p>这是该信号的默认超载。</p>
<p>当答复检测处理错误这个信号被发射。该<a href="qnetworkreply.html#finished" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#finished">finished</a>（）信号可能会遵循，这表明连接已经结束。</p>
<p>该<i>code</i>参数包含检测到的错误代码。通话<a href="qiodevice.html#errorString" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#errorString">errorString</a>（ ）取得的错误条件的文本表示。</p>
<p><b>Note:</b>不要删除对象连接到这个信号的插槽。使用<a href="qobject.html#deleteLater" tppabs="http://pyqt4doc.appspot.com/qobject.html#deleteLater">deleteLater</a>（ ） 。</p>
<p><b>See also</b> <a href="qnetworkreply.html#error" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#error">error</a>（）和<a href="qiodevice.html#errorString" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#errorString">errorString</a>（ ） 。</p>


<h3 class="fn">
<a name="finished"></a>void finished ()</h3>
<p>这是该信号的默认超载。</p>
<p>当回复已完成处理这个信号被发射。之后此信号被发射，将没有更多的更新到应答的数据或元数据。</p>
<p>除非<a href="qnetworkreply.html#close" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#close">close</a>（ ）被调用时，答复将仍然打开进行读取，所以数据可以通过调用来检索<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（）或<a href="qiodevice.html#readAll" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readAll">readAll</a>（ ） 。特别是，如果没有调用<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（）被提了出来的结果<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（ ） ，调用<a href="qiodevice.html#readAll" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readAll">readAll</a>（ ）将获取的全部内容<a href="qbytearray.html" tppabs="http://pyqt4doc.appspot.com/qbytearray.html">QByteArray</a>。</p>
<p>这个信号在配合发出<a href="qnetworkaccessmanager.html#finished" tppabs="http://pyqt4doc.appspot.com/qnetworkaccessmanager.html#finished">QNetworkAccessManager.finished</a>（ ）该信号的答复参数是这个对象。</p>
<p><b>Note:</b>不要删除对象连接到这个信号的插槽。使用<a href="qobject.html#deleteLater" tppabs="http://pyqt4doc.appspot.com/qobject.html#deleteLater">deleteLater</a>（ ） 。</p>
<p>您也可以使用<a href="qnetworkreply.html#isFinished" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#isFinished">isFinished</a>（）来检查一个<a href="qnetworkreply.html" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html">QNetworkReply</a>您收到成品（ ）信号前完成均匀。</p>
<p><b>See also</b> <a href="qnetworkreply.html#setFinished" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#setFinished">setFinished</a>（ ）<a href="qnetworkaccessmanager.html#finished" tppabs="http://pyqt4doc.appspot.com/qnetworkaccessmanager.html#finished">QNetworkAccessManager.finished</a>（）和<a href="qnetworkreply.html#isFinished" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#isFinished">isFinished</a>（ ） 。</p>


<h3 class="fn">
<a name="metaDataChanged"></a>void metaDataChanged ()</h3>
<p>这是该信号的默认超载。</p>
<p>这个信号被发射时在此回复的元数据更改。元数据是不是内容（数据）本身，包括网络报头的任何信息。在大多数情况下，元数据将完全由被接收数据的第一个字节时已知的。然而，能够将数据的处理过程中接收标题或其他元数据的更新。</p>
<p><b>See also</b> <a href="qnetworkreply.html#header" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#header">header</a>（ ）<a href="qnetworkreply.html#rawHeaderList" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#rawHeaderList">rawHeaderList</a>（ ）<a href="qnetworkreply.html#rawHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#rawHeader">rawHeader</a>（）和<a href="qnetworkreply.html#hasRawHeader" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#hasRawHeader">hasRawHeader</a>（ ） 。</p>


<h3 class="fn">
<a name="sslErrors"></a>void sslErrors (const QList&lt;QSslError&gt;&amp;)</h3>
<p>这是该信号的默认超载。</p>
<p>这个信号被发射，如果SSL / TLS会话期间，成立了包括证书验证错误，遇到错误。该<i>errors</i>参数包含错误的列表。</p>
<p>为了表明这些错误不是致命的，而连接应进行，<a href="qnetworkreply.html#ignoreSslErrors" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>（）函数应该被称为从连接到该信号的时隙。如果它不叫， SSL会话将被推倒的任何数据交换（包括URL）之前。</p>
<p>这个信号可以被用来显示一个错误消息，指示安全性可能会受到影响的用户，并显示在SSL设置（见<a href="qnetworkreply.html#sslConfiguration" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#sslConfiguration">sslConfiguration</a>（）来获取它） 。如果用户决定继续进行远程证明分析后，槽应调用<a href="qnetworkreply.html#ignoreSslErrors" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>（ ） 。</p>
<p><b>See also</b> <a href="qsslsocket.html#sslErrors" tppabs="http://pyqt4doc.appspot.com/qsslsocket.html#sslErrors">QSslSocket.sslErrors</a>（ ）<a href="qnetworkaccessmanager.html#sslErrors" tppabs="http://pyqt4doc.appspot.com/qnetworkaccessmanager.html#sslErrors">QNetworkAccessManager.sslErrors</a>（ ）<a href="qnetworkreply.html#sslConfiguration" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#sslConfiguration">sslConfiguration</a>（）和<a href="qnetworkreply.html#ignoreSslErrors" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#ignoreSslErrors">ignoreSslErrors</a>（ ） 。</p>


<h3 class="fn">
<a name="uploadProgress"></a>void uploadProgress (qint64,qint64)</h3>
<p>这是该信号的默认超载。</p>
<p>这个信号被发射，以指示该网络请求的载部分的进展，如果有任何。如果没有与该请求相关联的上载，该信号将不会被发射。</p>
<p>该<i>bytesSent</i>参数表示上传的字节数，而<i>bytesTotal</i>指示要被上传的总字节数。如果不能确定要上载的字节数，<i>bytesTotal</i>将为-1 。</p>
<p>上传完成后，当<i>bytesSent</i>等于<i>bytesTotal</i>。在那个时候，<i>bytesTotal</i>不会是-1。</p>
<p><b>See also</b> <a href="qnetworkreply.html#downloadProgress" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html#downloadProgress">downloadProgress</a>（ ） 。</p>


<address>
<div class="ad">
<br> 
<br><hr>
</div>
<div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address">
<td align="left" width="25%">PyQt 4.10.3 for X11</td>
<td align="center" width="50%">Copyright © <a href="http://www.riverbankcomputing.com/">Riverbank Computing Ltd</a> and <a href="http://www.qtsoftware.com/">Nokia</a> 2012</td>
<td align="right" width="25%">Qt 4.8.5</td>
</tr></table></div>
</address>
</body>
</html>