<html>
<head>
<title>QAbstractMessageHandler Class Reference</title>
<style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr></tr>
<td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" tppabs="http://pyqt4doc.appspot.com/images/rb-logo.png" width="32"></td>
<td width="1">  </td>
<td class="postheader" valign="center">
<a href="index.html" tppabs="http://pyqt4doc.appspot.com/index.html"><font color="#004faf">Home</font></a> · <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/classes.html"><font color="#004faf">All Classes</font></a> · <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/modules.html"><font color="#004faf">Modules</font></a>  · <a href="qss.html"><font color="#004faf">QSS HELP</font></a>  · <a href="qtqss.html"><font color="#004faf">QSS 案例</font></a> · <a href="HTTP://VER007.COM"><font color="#004faf">VER007 HOME</font></a> 
</td>
</table>
<h1 align="center">QAbstractMessageHandler Class Reference<br><sup><sup>[<a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qtxmlpatterns.html">QtXmlPatterns</a> module]</sup></sup>
</h1>
<p>该QAbstractMessageHandler类提供用于处理消息的回调接口。<a href="#details">More...</a></p>

<p>继承<a href="qobject.html" tppabs="http://pyqt4doc.appspot.com/qobject.html">QObject</a>。</p>
<h3>Methods</h3>
<ul>
<li>
<div class="fn"></div>
<b><a href="qabstractmessagehandler.html#QAbstractMessageHandler" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html#QAbstractMessageHandler">__init__</a></b> (<i>self</i>, QObject <i>parent</i> = None)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractmessagehandler.html#handleMessage" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html#handleMessage">handleMessage</a></b> (<i>self</i>, QtMsgType <i>type</i>, QString <i>description</i>, QUrl <i>identifier</i>, QSourceLocation <i>sourceLocation</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractmessagehandler.html#message" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html#message">message</a></b> (<i>self</i>, QtMsgType <i>type</i>, QString <i>description</i>, QUrl <i>identifier</i> = QUrl(), QSourceLocation <i>sourceLocation</i> = QSourceLocation())</li>
</ul>
<a name="details"></a><div class="ad">
<hr>
 
</div>
<h2>Detailed Description</h2>
<p>该QAbstractMessageHandler类提供用于处理消息的回调接口。</p>
<p>QAbstractMessageHandler是提供用于处理消息的回调接口的抽象基类。例如，类<a href="qxmlquery.html" tppabs="http://pyqt4doc.appspot.com/qxmlquery.html">QXmlQuery</a>分析和运行的<a href="index.htm" tppabs="http://pyqt4doc.appspot.com/xmlprocessing.html">XQuery</a>。当它检测到一个编译或运行时错误，它会生成一个相应的错误信息，而不是输出消息本身，它传递的消息到<a href="qabstractmessagehandler.html#message" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html#message">message</a>（ ）函数将其QAbstractMessageHandler的。看<a href="qxmlquery.html#setMessageHandler" tppabs="http://pyqt4doc.appspot.com/qxmlquery.html#setMessageHandler">QXmlQuery.setMessageHandler</a>（ ） 。</p>
<p>你通过继承QAbstractMessageHandler和实施创建消息处理程序<a href="qabstractmessagehandler.html#handleMessage" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html#handleMessage">handleMessage</a>（ ） 。然后，将指针传递给你的子类的实例必须生成消息的任何类。该消息通过发送到消息处理程序<a href="qabstractmessagehandler.html#message" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html#message">message</a>（ ）函数，该函数将它们转发给你的handleMessge （ ） 。其效果是序列化的所有消息的处理，这意味着你的QAbstractMessageHandler子类是线程安全的。</p>
<p>QAbstractMessageHandler的单个实例可以被调用来处理来自多个来源的消息。因此，消息的内容，它是<i>description</i>传递给参数<a href="qabstractmessagehandler.html#message" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html#message">message</a>（）和<a href="qabstractmessagehandler.html#handleMessage" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html#handleMessage">handleMessage</a>（ ） ，必须解释在光需要发送消息的上下文。这种情况下被指定的<i>identifier</i>和<i>sourceLocation</i>参数<a href="qabstractmessagehandler.html#message" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html#message">message</a>（ ）<a href="qabstractmessagehandler.html#handleMessage" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html#handleMessage">handleMessage</a>（ ） 。</p>
<hr>
<h2>Method Documentation</h2>
<h3 class="fn">
<a name="QAbstractMessageHandler"></a>QAbstractMessageHandler.__init__ (<i>self</i>, <a href="qobject.html" tppabs="http://pyqt4doc.appspot.com/qobject.html">QObject</a> <i>parent</i> = None)</h3>
<p>该<i>parent</i>的说法，如果不是没有，原因<i>self</i>通过Qt的，而不是PyQt的拥有。</p>
<p>构造一个<a href="qabstractmessagehandler.html" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html">QAbstractMessageHandler</a>。该<i>parent</i>被传递到<a href="qobject.html" tppabs="http://pyqt4doc.appspot.com/qobject.html">QObject</a>基类的构造函数。</p>


<h3 class="fn">
<a name="handleMessage"></a>QAbstractMessageHandler.handleMessage (<i>self</i>, <a href="index.htm#QtMsgType-enum" tppabs="http://pyqt4doc.appspot.com/qtcore.html#QtMsgType-enum">QtMsgType</a> <i>type</i>, QString <i>description</i>, <a href="qurl.html" tppabs="http://pyqt4doc.appspot.com/qurl.html">QUrl</a> <i>identifier</i>, <a href="qsourcelocation.html" tppabs="http://pyqt4doc.appspot.com/qsourcelocation.html">QSourceLocation</a> <i>sourceLocation</i>)</h3>
<p>这种方法是抽象的，应在任何子类中重新实现。</p>
<p>这个功能必须由子类来实现。<a href="qabstractmessagehandler.html#message" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html#message">message</a>（ ）会调用这个函数，传入的参数，<i>type</i>，<i>description</i>，<i>identifier</i>和<i>sourceLocation</i>未修改。</p>


<h3 class="fn">
<a name="message"></a>QAbstractMessageHandler.message (<i>self</i>, <a href="index.htm#QtMsgType-enum" tppabs="http://pyqt4doc.appspot.com/qtcore.html#QtMsgType-enum">QtMsgType</a> <i>type</i>, QString <i>description</i>, <a href="qurl.html" tppabs="http://pyqt4doc.appspot.com/qurl.html">QUrl</a> <i>identifier</i> = QUrl(), <a href="qsourcelocation.html" tppabs="http://pyqt4doc.appspot.com/qsourcelocation.html">QSourceLocation</a> <i>sourceLocation</i> = QSourceLocation())</h3>
<p>将消息发送到这个消息处理程序。<i>type</i>正在发送消息的种类。<i>description</i>是消息的内容。该<i>identifier</i>是标识的消息，是关键解释其他参数的URI 。</p>
<p>通常情况下，这个类是用于报告错误，是这样<a href="qxmlquery.html" tppabs="http://pyqt4doc.appspot.com/qxmlquery.html">QXmlQuery</a>，它采用了<a href="qabstractmessagehandler.html" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html">QAbstractMessageHandler</a>报告编译和运行时<a href="index.htm" tppabs="http://pyqt4doc.appspot.com/xmlprocessing.html">XQuery</a>错误。因此，使用一个<a href="qurl.html" tppabs="http://pyqt4doc.appspot.com/qurl.html">QUrl</a>作为消息<i>identifier</i>IS的灵感来自于的解释<a href="http://www.w3.org/TR/xquery/#errors">error handling in the XQuery
language</a>。因为<i>identifier</i>是由一个命名空间URI和本地部分，标识符具有相同本地部分是唯一的。来电者是负责确保<i>identifier</i>是一个有效的<a href="qurl.html" tppabs="http://pyqt4doc.appspot.com/qurl.html">QUrl</a>或默认构造<a href="qurl.html" tppabs="http://pyqt4doc.appspot.com/qurl.html">QUrl</a>。</p>
<p><i>sourceLocation</i>在一个资源（即，文件或文件）中检测是否需要报告一个消息，其中，识别一个位置。</p>
<p>这个函数直接调用<a href="qabstractmessagehandler.html#handleMessage" tppabs="http://pyqt4doc.appspot.com/qabstractmessagehandler.html#handleMessage">handleMessage</a>（ ） ，传递其所有参数不变。</p>
<p><b>See also</b> <a href="http://www.w3.org/TR/xquery/#errors">http://www.w3.org/TR/xquery/#errors</a>。</p>
<address>
<div class="ad">
<br> 
<br><hr>
</div>
<div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address">
<td align="left" width="25%">PyQt 4.10.3 for X11</td>
<td align="center" width="50%">Copyright © <a href="http://www.riverbankcomputing.com/">Riverbank Computing Ltd</a> and <a href="http://www.qtsoftware.com/">Nokia</a> 2012</td>
<td align="right" width="25%">Qt 4.8.5</td>
</tr></table></div>
</address>
</body>
</html>