<html>
<head>
<title>QAbstractSocket Class Reference</title>
<style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr></tr>
<td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" tppabs="http://pyqt4doc.appspot.com/images/rb-logo.png" width="32"></td>
<td width="1">  </td>
<td class="postheader" valign="center">
<a href="index.html" tppabs="http://pyqt4doc.appspot.com/index.html"><font color="#004faf">Home</font></a> · <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/classes.html"><font color="#004faf">All Classes</font></a> · <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/modules.html"><font color="#004faf">Modules</font></a>  · <a href="qss.html"><font color="#004faf">QSS HELP</font></a>  · <a href="qtqss.html"><font color="#004faf">QSS 案例</font></a> · <a href="HTTP://VER007.COM"><font color="#004faf">VER007 HOME</font></a> 
</td>
</table>
<h1 align="center">QAbstractSocket Class Reference<br><sup><sup>[<a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qtnetwork.html">QtNetwork</a> module]</sup></sup>
</h1>
<p>该QAbstractSocket类提供通用于所有的套接字类型的基本功能。<a href="#details">More...</a></p>

<p>继承<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>。</p>
<p>通过继承<a href="qtcpsocket.html" tppabs="http://pyqt4doc.appspot.com/qtcpsocket.html">QTcpSocket</a>和<a href="qudpsocket.html" tppabs="http://pyqt4doc.appspot.com/qudpsocket.html">QUdpSocket</a>。</p>
<h3>Types</h3>
<ul>
<li>
<div class="fn"></div>enum <b><a href="qabstractsocket.html#NetworkLayerProtocol-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#NetworkLayerProtocol-enum">NetworkLayerProtocol</a></b> { IPv4Protocol, IPv6Protocol, UnknownNetworkLayerProtocol }</li>
<li>
<div class="fn"></div>enum <b><a href="qabstractsocket.html#SocketError-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketError-enum">SocketError</a></b> { ConnectionRefusedError, RemoteHostClosedError, HostNotFoundError, SocketAccessError, ..., UnknownSocketError }</li>
<li>
<div class="fn"></div>enum <b><a href="qabstractsocket.html#SocketOption-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketOption-enum">SocketOption</a></b> { LowDelayOption, KeepAliveOption, MulticastTtlOption, MulticastLoopbackOption }</li>
<li>
<div class="fn"></div>enum <b><a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">SocketState</a></b> { UnconnectedState, HostLookupState, ConnectingState, ConnectedState, ..., ClosingState }</li>
<li>
<div class="fn"></div>enum <b><a href="qabstractsocket.html#SocketType-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketType-enum">SocketType</a></b> { TcpSocket, UdpSocket, UnknownSocketType }</li>
</ul>
<h3>Methods</h3>
<ul>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#QAbstractSocket" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#QAbstractSocket">__init__</a></b> (<i>self</i>, SocketType <i>socketType</i>, QObject <i>parent</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#abort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#abort">abort</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qabstractsocket.html#atEnd" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#atEnd">atEnd</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qabstractsocket.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#bytesAvailable">bytesAvailable</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qabstractsocket.html#bytesToWrite" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#bytesToWrite">bytesToWrite</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qabstractsocket.html#canReadLine" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#canReadLine">canReadLine</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#close" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#close">close</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a></b> (<i>self</i>, QString <i>hostName</i>, int <i>port</i>, QIODevice.OpenMode <i>mode</i> = QIODevice.ReadWrite)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#connectToHost-2" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost-2">connectToHost</a></b> (<i>self</i>, QHostAddress <i>address</i>, int <i>port</i>, QIODevice.OpenMode <i>mode</i> = QIODevice.ReadWrite)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#connectToHostImplementation" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHostImplementation">connectToHostImplementation</a></b> (<i>self</i>, QString <i>hostName</i>, int <i>port</i>, QIODevice.OpenMode <i>mode</i> = QIODevice.ReadWrite)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#disconnectFromHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnectFromHost">disconnectFromHost</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#disconnectFromHostImplementation" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnectFromHostImplementation">disconnectFromHostImplementation</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>SocketError <b><a href="qabstractsocket.html#error" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#error">error</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qabstractsocket.html#flush" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#flush">flush</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qabstractsocket.html#isSequential" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#isSequential">isSequential</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qabstractsocket.html#isValid" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#isValid">isValid</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QHostAddress <b><a href="qabstractsocket.html#localAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#localAddress">localAddress</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qabstractsocket.html#localPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#localPort">localPort</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QHostAddress <b><a href="qabstractsocket.html#peerAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerAddress">peerAddress</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QString <b><a href="qabstractsocket.html#peerName" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerName">peerName</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qabstractsocket.html#peerPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerPort">peerPort</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QNetworkProxy <b><a href="qabstractsocket.html#proxy" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#proxy">proxy</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qabstractsocket.html#readBufferSize" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#readBufferSize">readBufferSize</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>str <b><a href="qabstractsocket.html#readData" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#readData">readData</a></b> (<i>self</i>, int <i>maxlen</i>)</li>
<li>
<div class="fn"></div>str <b><a href="qabstractsocket.html#readLineData" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#readLineData">readLineData</a></b> (<i>self</i>, int <i>maxlen</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#setLocalAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setLocalAddress">setLocalAddress</a></b> (<i>self</i>, QHostAddress <i>address</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#setLocalPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setLocalPort">setLocalPort</a></b> (<i>self</i>, int <i>port</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#setPeerAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setPeerAddress">setPeerAddress</a></b> (<i>self</i>, QHostAddress <i>address</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#setPeerName" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setPeerName">setPeerName</a></b> (<i>self</i>, QString <i>name</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#setPeerPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setPeerPort">setPeerPort</a></b> (<i>self</i>, int <i>port</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#setProxy" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setProxy">setProxy</a></b> (<i>self</i>, QNetworkProxy <i>networkProxy</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#setReadBufferSize" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setReadBufferSize">setReadBufferSize</a></b> (<i>self</i>, int <i>size</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qabstractsocket.html#setSocketDescriptor" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setSocketDescriptor">setSocketDescriptor</a></b> (<i>self</i>, int <i>socketDescriptor</i>, SocketState <i>state</i> = QAbstractSocket.ConnectedState, QIODevice.OpenMode <i>mode</i> = QIODevice.ReadWrite)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#setSocketError" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setSocketError">setSocketError</a></b> (<i>self</i>, SocketError <i>socketError</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#setSocketOption" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setSocketOption">setSocketOption</a></b> (<i>self</i>, SocketOption <i>option</i>, QVariant <i>value</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qabstractsocket.html#setSocketState" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setSocketState">setSocketState</a></b> (<i>self</i>, SocketState <i>state</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qabstractsocket.html#socketDescriptor" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#socketDescriptor">socketDescriptor</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QVariant <b><a href="qabstractsocket.html#socketOption" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#socketOption">socketOption</a></b> (<i>self</i>, SocketOption <i>option</i>)</li>
<li>
<div class="fn"></div>SocketType <b><a href="qabstractsocket.html#socketType" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#socketType">socketType</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>SocketState <b><a href="qabstractsocket.html#state" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#state">state</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qabstractsocket.html#waitForBytesWritten" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#waitForBytesWritten">waitForBytesWritten</a></b> (<i>self</i>, int <i>msecs</i> = 30000)</li>
<li>
<div class="fn"></div>bool <b><a href="qabstractsocket.html#waitForConnected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#waitForConnected">waitForConnected</a></b> (<i>self</i>, int <i>msecs</i> = 30000)</li>
<li>
<div class="fn"></div>bool <b><a href="qabstractsocket.html#waitForDisconnected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#waitForDisconnected">waitForDisconnected</a></b> (<i>self</i>, int <i>msecs</i> = 30000)</li>
<li>
<div class="fn"></div>bool <b><a href="qabstractsocket.html#waitForReadyRead" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#waitForReadyRead">waitForReadyRead</a></b> (<i>self</i>, int <i>msecs</i> = 30000)</li>
<li>
<div class="fn"></div>int <b><a href="qabstractsocket.html#writeData" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#writeData">writeData</a></b> (<i>self</i>, str <i>data</i>)</li>
</ul>
<h3>Qt Signals</h3>
<ul>
<li>
<div class="fn"></div>void <b><a href="qabstractsocket.html#connected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connected">connected</a></b> ()</li>
<li>
<div class="fn"></div>void <b><a href="qabstractsocket.html#disconnected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnected">disconnected</a></b> ()</li>
<li>
<div class="fn"></div>void <b><a href="qabstractsocket.html#error-2" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#error-2">error</a></b> (QAbstractSocket::SocketError)</li>
<li>
<div class="fn"></div>void <b><a href="qabstractsocket.html#hostFound" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#hostFound">hostFound</a></b> ()</li>
<li>
<div class="fn"></div>void <b><a href="qabstractsocket.html#proxyAuthenticationRequired" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#proxyAuthenticationRequired">proxyAuthenticationRequired</a></b> (const QNetworkProxy&amp;,QAuthenticator *)</li>
<li>
<div class="fn"></div>void <b><a href="qabstractsocket.html#stateChanged" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#stateChanged">stateChanged</a></b> (QAbstractSocket::SocketState)</li>
</ul>
<a name="details"></a><div class="ad">
<hr>
 
</div>
<h2>Detailed Description</h2>
<p>该QAbstractSocket类提供通用于所有的套接字类型的基本功能。</p>
<p>QAbstractSocket为基类<a href="qtcpsocket.html" tppabs="http://pyqt4doc.appspot.com/qtcpsocket.html">QTcpSocket</a>和<a href="qudpsocket.html" tppabs="http://pyqt4doc.appspot.com/qudpsocket.html">QUdpSocket</a>并包含这两个类的所有常见功能。如果你需要一个插座，你有两种选择：</p>
<ul>
<li>Instantiate <a href="qtcpsocket.html" tppabs="http://pyqt4doc.appspot.com/qtcpsocket.html">QTcpSocket</a> or
<a href="qudpsocket.html" tppabs="http://pyqt4doc.appspot.com/qudpsocket.html">QUdpSocket</a>.</li>
<li>Create a native socket descriptor, instantiate QAbstractSocket,
and call <a href="qabstractsocket.html#setSocketDescriptor" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setSocketDescriptor">setSocketDescriptor</a>()
to wrap the native socket.</li>
</ul>
<p>TCP（传输控制协议）是一种可靠的，面向流的，面向连接的传输协议。 UDP（用户数据报协议）是一种不可靠的，面向数据报的，无连接的协议。在实践中，这意味着TCP是更适合于数据的连续发送，而当可靠性是不重要的，轻量级的UDP都可以使用。</p>
<p>QAbstractSocket的API，最统一的两个协议之间的差异。例如，虽然UDP是无连接的，<a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（ ）建立了UDP套接字的虚拟连接，使您能够在或多或少的相同方式使用QAbstractSocket不管底层协议。在内部， QAbstractSocket记得传递给地址和端口<a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（） ，和类似的功能<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（）和<a href="qiodevice.html#write" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#write">write</a>（）中使用这些值。</p>
<p>在任何时候， QAbstractSocket具有状态（返回<a href="qabstractsocket.html#state" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#state">state</a>（））。初始状态是<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">UnconnectedState</a>。后调用<a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（） ，插座首先进入<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">HostLookupState</a>。如果发现主机， QAbstractSocket进入<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">ConnectingState</a>和发射<a href="qabstractsocket.html#hostFound" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#hostFound">hostFound</a>（）信号。当连接已经建立时，它进入<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">ConnectedState</a>并发出<a href="qabstractsocket.html#connected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connected">connected</a>（ ） 。如果发生错误，在任何阶段，<a href="qabstractsocket.html#error" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#error">error</a>（）被发射。每当状态发生变化，<a href="qabstractsocket.html#stateChanged" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#stateChanged">stateChanged</a>（）被发射。为方便起见，<a href="qabstractsocket.html#isValid" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#isValid">isValid</a>（ ）返回True如果套接字已准备好进行读取和写入，但请注意，插座的状态必须<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">ConnectedState</a>阅读和写作之前可能发生。</p>
<p>通过调用读取或写入数据<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（）或<a href="qiodevice.html#write" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#write">write</a>（ ） ，或者使用的方便功能<a href="qiodevice.html#readLine" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLine">readLine</a>（）和<a href="qiodevice.html#readAll" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readAll">readAll</a>（ ） 。 QAbstractSocket也继承<a href="qiodevice.html#getChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#getChar">getChar</a>（ ）<a href="qiodevice.html#putChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#putChar">putChar</a>（）和<a href="qiodevice.html#ungetChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#ungetChar">ungetChar</a>（ ）从<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>，其中单字节工作。该<a href="qiodevice.html#bytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesWritten">bytesWritten</a>当数据已经被写入到插座（即，当客户端已读出的数据）（ ）信号被发射。注意Qt不限制写入缓冲区的大小。您可以通过听这个信号监视它的大小。</p>
<p>该<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>每一个新的数据块已到达的时间（）信号被发射。<a href="qabstractsocket.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#bytesAvailable">bytesAvailable</a>（）然后返回可用于读取的字节数。通常情况下，您将在<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（）信号到一个槽和阅读有所有可用的数据。如果你不立即读取所有数据，其馀数据仍然可用后，任何新进入的数据将被追加到QAbstractSocket的内部读缓冲区。来限制读缓冲区的大小，调用<a href="qabstractsocket.html#setReadBufferSize" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setReadBufferSize">setReadBufferSize</a>（ ） 。</p>
<p>关闭套接字，调用<a href="qabstractsocket.html#disconnectFromHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>（ ） 。 QAbstractSocket进入<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">QAbstractSocket.ClosingState</a>。在所有挂起的数据已经写入到socket ， QAbstractSocket实际上关闭套接字，进入QAbstractSocket.ClosedState ，并发出<a href="qabstractsocket.html#disconnected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnected">disconnected</a>（ ） 。如果您想立即中止连接，丢弃所有未决的数据，调用<a href="qabstractsocket.html#abort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#abort">abort</a>（ ）来代替。如果远程主机关闭连接， QAbstractSocket会发出错误（<a href="qabstractsocket.html#SocketError-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketError-enum">QAbstractSocket.RemoteHostClosedError</a>） ，在此期间，插座状态仍将是<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">ConnectedState</a>，然后在<a href="qabstractsocket.html#disconnected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnected">disconnected</a>（）信号将被发射。</p>
<p>所连接的对端的端口和地址是通过调用取<a href="qabstractsocket.html#peerPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerPort">peerPort</a>（）和<a href="qabstractsocket.html#peerAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerAddress">peerAddress</a>（ ） 。<a href="qabstractsocket.html#peerName" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerName">peerName</a>（）返回对端的主机名，它被传递到<a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（ ） 。<a href="qabstractsocket.html#localPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#localPort">localPort</a>（）和<a href="qabstractsocket.html#localAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#localAddress">localAddress</a>（ ）返回本地套接字的端口和地址。</p>
<p>QAbstractSocket提供了一组挂起调用线程，直到某个信号发射的功能。这些功能可以用来实现阻塞套接字：</p>
<ul>
<li>
<a href="qabstractsocket.html#waitForConnected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#waitForConnected">waitForConnected</a>()
blocks until a connection has been established.</li>
<li>
<a href="qabstractsocket.html#waitForReadyRead" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#waitForReadyRead">waitForReadyRead</a>()
blocks until new data is available for reading.</li>
<li>
<a href="qabstractsocket.html#waitForBytesWritten" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#waitForBytesWritten">waitForBytesWritten</a>()
blocks until one payload of data has been written to the
socket.</li>
<li>
<a href="qabstractsocket.html#waitForDisconnected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#waitForDisconnected">waitForDisconnected</a>()
blocks until the connection has closed.</li>
</ul>
<p>我们显示一个例子：</p>
<pre class="cpp">
     <span class="type">int</span> numRead <span class="operator">=</span> <span class="number">0</span><span class="operator">,</span> numReadTotal <span class="operator">=</span> <span class="number">0</span>;
     <span class="type">char</span> buffer<span class="operator">[</span><span class="number">50</span><span class="operator">]</span>;

     forever {
         numRead  <span class="operator">=</span> socket<span class="operator">.</span>read(buffer<span class="operator">,</span> <span class="number">50</span>);

         <span class="comment">// do whatever with array</span>

         numReadTotal <span class="operator">+</span><span class="operator">=</span> numRead;
         <span class="keyword">if</span> (numRead <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="operator">!</span>socket<span class="operator">.</span>waitForReadyRead())
             <span class="keyword">break</span>;
     }
</pre>
<p>If <a href="qiodevice.html#waitForReadyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#waitForReadyRead">waitForReadyRead()</a>返回False ，该连接已关闭或发生错误。</p>
<p>与阻塞套接字编程是一个非阻塞套接字编程完全不同。阻塞套接字并不需要一个事件循环，并通常会导致简单的代码。然而，在一个图形用户界面的应用程序，阻塞插座只应在非GUI线程使用，以避免冻结的用户界面。请参阅<a href="index.htm" tppabs="http://pyqt4doc.appspot.com/network-fortuneclient.html">network/fortuneclient</a>和<a href="index.htm" tppabs="http://pyqt4doc.appspot.com/network-blockingfortuneclient.html">network/blockingfortuneclient</a>举例而言，两种方法的概述。</p>
<p><b>Note:</b>我们不鼓励使用的阻塞函数信号一起。应该使用其中的两种可能性。</p>
<p>QAbstractSocket可以被用于<a href="qtextstream.html" tppabs="http://pyqt4doc.appspot.com/qtextstream.html">QTextStream</a>和<a href="qdatastream.html" tppabs="http://pyqt4doc.appspot.com/qdatastream.html">QDataStream</a>的流运算符（运算符\u003c\u003c （）和operator \u003e\u003e （ ） ） 。有一个问题需要注意，虽然：你必须确保有足够的数据可用尝试使用运算符来读取它之前\u003e\u003e （ ） 。</p>
<hr>
<h2>Type Documentation</h2>
<h3 class="fn">
<a name="NetworkLayerProtocol-enum"></a>QAbstractSocket.NetworkLayerProtocol</h3>
<p>这个枚举变量描述的Qt使用的网络层协议的值。</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.IPv4Protocol</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">IPv4的</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.IPv6Protocol</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">IPv6的</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.UnknownNetworkLayerProtocol</tt>
</td>
<td class="topAlign"><tt>-1</tt></td>
<td class="topAlign">除IPv4和IPv6</td>
</tr>
</table>
<p><b>See also</b> <a href="qhostaddress.html#protocol" tppabs="http://pyqt4doc.appspot.com/qhostaddress.html#protocol">QHostAddress.protocol</a>（ ） 。</p>


<h3 class="fn">
<a name="SocketError-enum"></a>QAbstractSocket.SocketError</h3>
<p>这个枚举说明可能发生的套接字错误。</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ConnectionRefusedError</tt>
</td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">连接被对等（或超时）拒绝。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.RemoteHostClosedError</tt>
</td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">远程主机关闭了连接。请注意，客户端套接字（也就是该套接字）远程关闭通知发出后将会关闭。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.HostNotFoundError</tt>
</td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">主机地址未找到。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.SocketAccessError</tt>
</td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">套接字操作失败，因为该应用程序缺乏必要的特权。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.SocketResourceError</tt>
</td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">本地系统跑出来的资源（例如，太多的套接字）的。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.SocketTimeoutError</tt>
</td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">套接字操作超时。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.DatagramTooLargeError</tt>
</td>
<td class="topAlign"><tt>6</tt></td>
<td class="topAlign">数据报比操作系统的限制（其可以是低至8192字节）大。</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.NetworkError</tt></td>
<td class="topAlign"><tt>7</tt></td>
<td class="topAlign">与网络（例如，网络电缆被意外拔出）时发生错误。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.AddressInUseError</tt>
</td>
<td class="topAlign"><tt>8</tt></td>
<td class="topAlign">指定的地址<a href="qudpsocket.html#bind" tppabs="http://pyqt4doc.appspot.com/qudpsocket.html#bind">QUdpSocket.bind</a>（）已经在使用中并且被设置为独占的。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.SocketAddressNotAvailableError</tt>
</td>
<td class="topAlign"><tt>9</tt></td>
<td class="topAlign">指定的地址<a href="qudpsocket.html#bind" tppabs="http://pyqt4doc.appspot.com/qudpsocket.html#bind">QUdpSocket.bind</a>（ ）不属于主机。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.UnsupportedSocketOperationError</tt>
</td>
<td class="topAlign"><tt>10</tt></td>
<td class="topAlign">不是由本地操作系统（例如，缺乏支持IPv6 ）的支持请求的套接字操作。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ProxyAuthenticationRequiredError</tt>
</td>
<td class="topAlign"><tt>12</tt></td>
<td class="topAlign">该插座是使用代理，而代理服务器需要身份验证。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.SslHandshakeFailedError</tt>
</td>
<td class="topAlign"><tt>13</tt></td>
<td class="topAlign">在SSL / TLS握手失败，因此连接已关闭（仅在使用<a href="qsslsocket.html" tppabs="http://pyqt4doc.appspot.com/qsslsocket.html">QSslSocket</a>） （此值被引入4.4 。 ）</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.UnfinishedSocketOperationError</tt>
</td>
<td class="topAlign"><tt>11</tt></td>
<td class="topAlign">使用QAbstractSocketEngine只，最后的操作尝试尚未完成（仍然在后台进程） 。 （这个值被引入4.4 。 ）</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ProxyConnectionRefusedError</tt>
</td>
<td class="topAlign"><tt>14</tt></td>
<td class="topAlign">无法联系的代理服务器，因为连接到该服务器被拒绝（这个值被引入4.5 。 ）</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ProxyConnectionClosedError</tt>
</td>
<td class="topAlign"><tt>15</tt></td>
<td class="topAlign">到代理服务器的连接意外被关闭（连接到最终的同行建立之前） （此值是在4.5推出。 ）</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ProxyConnectionTimeoutError</tt>
</td>
<td class="topAlign"><tt>16</tt></td>
<td class="topAlign">到代理服务器的连接超时或代理服务器停在认证阶段响应。 （这个值被引入4.5 。 ）</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ProxyNotFoundError</tt>
</td>
<td class="topAlign"><tt>17</tt></td>
<td class="topAlign">设置代理地址<a href="qabstractsocket.html#setProxy" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setProxy">setProxy</a>（ ） （或应用程序代理）未找到。 （这个值被引入4.5 。 ）</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.ProxyProtocolError</tt>
</td>
<td class="topAlign"><tt>18</tt></td>
<td class="topAlign">在连接协商与代理服务器，因为从代理服务器的响应无法被理解。 （这个值被引入4.5 。 ）</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.UnknownSocketError</tt>
</td>
<td class="topAlign"><tt>-1</tt></td>
<td class="topAlign">发生不明的错误。</td>
</tr>
</table>
<p><b>See also</b> <a href="qabstractsocket.html#error" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#error">QAbstractSocket.error</a>（ ） 。</p>


<h3 class="fn">
<a name="SocketOption-enum"></a>QAbstractSocket.SocketOption</h3>
<p>这个枚举表示可以在一个插座可以设置的选项。如果需要的话，它们可以在接收之后进行设置<a href="qabstractsocket.html#connected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connected">connected</a>（）从插座或收到一个新的套接字从后信号<a href="qtcpserver.html" tppabs="http://pyqt4doc.appspot.com/qtcpserver.html">QTcpServer</a>。</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.LowDelayOption</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">尝试优化插座低延迟。对于<a href="qtcpsocket.html" tppabs="http://pyqt4doc.appspot.com/qtcpsocket.html">QTcpSocket</a>这将设置TCP_NODELAY选项，并禁用Nagle算法。将此值设置为1来启用。</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.KeepAliveOption</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">将此值设置为1，以启用SO_KEEPALIVE套接字选项</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.MulticastTtlOption</tt>
</td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">将其设置为一个整数值来设置IP_MULTICAST_TTL （TTL组播数据报）套接字选项。</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.MulticastLoopbackOption</tt>
</td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">将此值设置为1 ，使IP_MULTICAST_LOOP （多播环回）套接字选项。</td>
</tr>
</table>
<p>这个枚举被引入或修改的Qt 4.6 。</p>
<p><b>See also</b> <a href="qabstractsocket.html#setSocketOption" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setSocketOption">QAbstractSocket.setSocketOption</a>（）和<a href="qabstractsocket.html#socketOption" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#socketOption">QAbstractSocket.socketOption</a>（ ） 。</p>


<h3 class="fn">
<a name="SocketState-enum"></a>QAbstractSocket.SocketState</h3>
<p>这个枚举变量描述了不同的状态，其中一个插座即可。</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.UnconnectedState</tt>
</td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">该套接字没有连接。</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.HostLookupState</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">该插座是执行主机名查找。</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.ConnectingState</tt></td>
<td class="topAlign"><tt>2</tt></td>
<td class="topAlign">插座已经开始建立连接。</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.ConnectedState</tt></td>
<td class="topAlign"><tt>3</tt></td>
<td class="topAlign">连接建立。</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.BoundState</tt></td>
<td class="topAlign"><tt>4</tt></td>
<td class="topAlign">套接字绑定到一个地址和端口（用于服务器） 。</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.ClosingState</tt></td>
<td class="topAlign"><tt>6</tt></td>
<td class="topAlign">该插座是即将关闭（数据仍可能等待写入） 。</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.ListeningState</tt></td>
<td class="topAlign"><tt>5</tt></td>
<td class="topAlign">仅供内部使用。</td>
</tr>
</table>
<p><b>See also</b> <a href="qabstractsocket.html#state" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#state">QAbstractSocket.state</a>（ ） 。</p>


<h3 class="fn">
<a name="SocketType-enum"></a>QAbstractSocket.SocketType</h3>
<p>这个枚举变量描述传输层协议。</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.TcpSocket</tt></td>
<td class="topAlign"><tt>0</tt></td>
<td class="topAlign">TCP</td>
</tr>
<tr>
<td class="topAlign"><tt>QAbstractSocket.UdpSocket</tt></td>
<td class="topAlign"><tt>1</tt></td>
<td class="topAlign">UDP</td>
</tr>
<tr>
<td class="topAlign">
<tt>QAbstractSocket.UnknownSocketType</tt>
</td>
<td class="topAlign"><tt>-1</tt></td>
<td class="topAlign">除了TCP和UDP</td>
</tr>
</table>
<p><b>See also</b> <a href="qabstractsocket.html#socketType" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#socketType">QAbstractSocket.socketType</a>（ ） 。</p>
<hr>
<h2>Method Documentation</h2>
<h3 class="fn">
<a name="QAbstractSocket"></a>QAbstractSocket.__init__ (<i>self</i>, <a href="qabstractsocket.html#SocketType-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketType-enum">SocketType</a> <i>socketType</i>, <a href="qobject.html" tppabs="http://pyqt4doc.appspot.com/qobject.html">QObject</a> <i>parent</i>)</h3>
<p>该<i>parent</i>的说法，如果不是没有，原因<i>self</i>通过Qt的，而不是PyQt的拥有。</p>
<p>创建类型的新抽象插座<i>socketType</i>。该<i>parent</i>参数被传递给<a href="qobject.html" tppabs="http://pyqt4doc.appspot.com/qobject.html">QObject</a>的构造。</p>
<p><b>See also</b> <a href="qabstractsocket.html#socketType" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#socketType">socketType</a>（ ）<a href="qtcpsocket.html" tppabs="http://pyqt4doc.appspot.com/qtcpsocket.html">QTcpSocket</a>和<a href="qudpsocket.html" tppabs="http://pyqt4doc.appspot.com/qudpsocket.html">QUdpSocket</a>。</p>


<h3 class="fn">
<a name="abort"></a>QAbstractSocket.abort (<i>self</i>)</h3>
<p>中止当前连接并重置插口。不像<a href="qabstractsocket.html#disconnectFromHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>（ ） ，这个函数立即关闭套接字，丢弃在写缓冲区任何挂起的数据。</p>
<p><b>See also</b> <a href="qabstractsocket.html#disconnectFromHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>（）和<a href="qabstractsocket.html#close" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#close">close</a>（ ） 。</p>


<h3 class="fn">
<a name="atEnd"></a>bool QAbstractSocket.atEnd (<i>self</i>)</h3>
<p>从重新实现<a href="qiodevice.html#atEnd" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#atEnd">QIODevice.atEnd</a>（ ） 。</p>
<p>如果没有更多的数据，目前可供读取，则返回True ，否则返回False 。</p>
<p>读数从插座在一个循环中的数据时，此功能是最常用的。例如：</p>
<pre class="cpp">
  <span class="comment">// This slot is connected to QAbstractSocket.readyRead()</span>
  <span class="type">void</span> SocketClass<span class="operator">.</span>readyReadSlot()
  {
      <span class="keyword">while</span> (<span class="operator">!</span>socket<span class="operator">.</span>atEnd()) {
          <span class="type"><a href="qbytearray.html" tppabs="http://pyqt4doc.appspot.com/qbytearray.html">QByteArray</a></span> data <span class="operator">=</span> socket<span class="operator">.</span>read(<span class="number">100</span>);
          <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
      }
  }
</pre>
<p><b>See also</b> <a href="qabstractsocket.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#bytesAvailable">bytesAvailable</a>（）和<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（ ） 。</p>


<h3 class="fn">
<a name="bytesAvailable"></a>int QAbstractSocket.bytesAvailable (<i>self</i>)</h3>
<p>从重新实现<a href="qiodevice.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesAvailable">QIODevice.bytesAvailable</a>（ ） 。</p>
<p>返回传入的字节正在等待被读取的次数。</p>
<p><b>See also</b> <a href="qabstractsocket.html#bytesToWrite" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#bytesToWrite">bytesToWrite</a>（）和<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（ ） 。</p>


<h3 class="fn">
<a name="bytesToWrite"></a>int QAbstractSocket.bytesToWrite (<i>self</i>)</h3>
<p>从重新实现<a href="qiodevice.html#bytesToWrite" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesToWrite">QIODevice.bytesToWrite</a>（ ） 。</p>
<p>返回正在等待被写入的字节数。该字节被写入时，控制返回到事件循环或当<a href="qabstractsocket.html#flush" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#flush">flush</a>（）被调用。</p>
<p><b>See also</b> <a href="qabstractsocket.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#bytesAvailable">bytesAvailable</a>（）和<a href="qabstractsocket.html#flush" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#flush">flush</a>（ ） 。</p>


<h3 class="fn">
<a name="canReadLine"></a>bool QAbstractSocket.canReadLine (<i>self</i>)</h3>
<p>从重新实现<a href="qiodevice.html#canReadLine" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#canReadLine">QIODevice.canReadLine</a>（ ） 。</p>
<p>返回True如果一行数据可以从套接字读取，否则返回False 。</p>
<p><b>See also</b> <a href="qiodevice.html#readLine" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLine">readLine</a>（ ） 。</p>


<h3 class="fn">
<a name="close"></a>QAbstractSocket.close (<i>self</i>)</h3>
<p>从重新实现<a href="qiodevice.html#close" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#close">QIODevice.close</a>（ ） 。</p>
<p>关闭套接字的I / O设备，断开与主机插座的连接，关闭套接字，并重置姓名，地址，端口号和底层套接字描述符。</p>
<p>See <a href="qiodevice.html#close" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#close">QIODevice.close</a>（ ），用于当一个I / O设备被关闭时发生的动作的说明。</p>
<p><b>See also</b> <a href="qabstractsocket.html#abort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#abort">abort</a>（ ） 。</p>


<h3 class="fn">
<a name="connectToHost"></a>QAbstractSocket.connectToHost (<i>self</i>, QString <i>hostName</i>, int <i>port</i>, <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qiodevice-openmode.html">QIODevice.OpenMode</a> <i>mode</i> = QIODevice.ReadWrite)</h3>
<p>企图使一个连接<i>hostName</i>在给定的<i>port</i>。</p>
<p>该插座是在给定的开<i>openMode</i>并首次进入<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">HostLookupState</a>，然后执行一个主机名查找<i>hostName</i>。如果查找成功，<a href="qabstractsocket.html#hostFound" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#hostFound">hostFound</a>（）被发射和<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>进入<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">ConnectingState</a>。然后，它尝试连接到由查询返回的地址或地址。最后，如果建立了连接，<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>进入<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">ConnectedState</a>并发出<a href="qabstractsocket.html#connected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connected">connected</a>（ ） 。</p>
<p>在任何点，该插座能发射<a href="qabstractsocket.html#error" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#error">error</a>（）来通知发生了错误。</p>
<p><i>hostName</i>可以是字符串形式（例如，“ 43.195.83.32 ” ）的IP地址，也可以是主机名（例如，“ example.com ” ） 。<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>会做只有当需要查找。<i>port</i>是在本地字节顺序。</p>
<p><b>See also</b> <a href="qabstractsocket.html#state" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#state">state</a>（ ）<a href="qabstractsocket.html#peerName" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerName">peerName</a>（ ）<a href="qabstractsocket.html#peerAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerAddress">peerAddress</a>（ ）<a href="qabstractsocket.html#peerPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerPort">peerPort</a>（）和<a href="qabstractsocket.html#waitForConnected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#waitForConnected">waitForConnected</a>（ ） 。</p>


<h3 class="fn">
<a name="connectToHost-2"></a>QAbstractSocket.connectToHost (<i>self</i>, <a href="qhostaddress.html" tppabs="http://pyqt4doc.appspot.com/qhostaddress.html">QHostAddress</a> <i>address</i>, int <i>port</i>, <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qiodevice-openmode.html">QIODevice.OpenMode</a> <i>mode</i> = QIODevice.ReadWrite)</h3>
<p>这是一个重载函数。</p>
<p>企图使一个连接<i>address</i>端口<i>port</i>。</p>


<h3 class="fn">
<a name="connectToHostImplementation"></a>QAbstractSocket.connectToHostImplementation (<i>self</i>, QString <i>hostName</i>, int <i>port</i>, <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qiodevice-openmode.html">QIODevice.OpenMode</a> <i>mode</i> = QIODevice.ReadWrite)</h3>
<p>这种方法也是一个Qt槽与C + +的签名<tt>void connectToHostImplementation(const QString&amp;,quint16,QIODevice::OpenMode = QIODevice.ReadWrite)</tt>。</p>
<p>包含的实施<a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（ ） 。</p>
<p>企图使一个连接<i>hostName</i>在给定的<i>port</i>。该插座是在给定的开<i>openMode</i>。</p>
<p>这个函数是Qt 4.1中引入。</p>


<h3 class="fn">
<a name="disconnectFromHost"></a>QAbstractSocket.disconnectFromHost (<i>self</i>)</h3>
<p>试图关闭套接字。如果有挂起的数据等待写入，<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>将进入<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">ClosingState</a>并等待，直到所有数据已经写入。最终，将进入<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">UnconnectedState</a>和发射<a href="qabstractsocket.html#disconnected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnected">disconnected</a>（）信号。</p>
<p><b>See also</b> <a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（ ） 。</p>


<h3 class="fn">
<a name="disconnectFromHostImplementation"></a>QAbstractSocket.disconnectFromHostImplementation (<i>self</i>)</h3>
<p>这种方法也是一个Qt槽与C + +的签名<tt>void disconnectFromHostImplementation()</tt>。</p>
<p>包含的实施<a href="qabstractsocket.html#disconnectFromHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>（ ） 。</p>
<p>这个函数是Qt 4.1中引入。</p>


<h3 class="fn">
<a name="error"></a><a href="qabstractsocket.html#SocketError-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketError-enum">SocketError</a> QAbstractSocket.error (<i>self</i>)</h3>
<p>返回上次发生错误的类型。</p>
<p><b>See also</b> <a href="qabstractsocket.html#state" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#state">state</a>（）和<a href="qiodevice.html#errorString" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#errorString">errorString</a>（ ） 。</p>


<h3 class="fn">
<a name="flush"></a>bool QAbstractSocket.flush (<i>self</i>)</h3>
<p>该函数将尽可能从内部写缓冲区的底层网络接口，而不会阻塞。如果任何数据被写入时，该函数将返回True，否则返回False。</p>
<p>调用此函数，如果你需要<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>立即开始发送缓冲数据。成功写入的字节数依赖于操作系统。在大多数情况下，你不需要调用这个函数，因为<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>将自动开始发送数据，一旦控制返回到事件循环。在不存在的事件循环，调用<a href="qabstractsocket.html#waitForBytesWritten" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#waitForBytesWritten">waitForBytesWritten</a>（ ）来代替。</p>
<p><b>See also</b> <a href="qiodevice.html#write" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#write">write</a>（）和<a href="qabstractsocket.html#waitForBytesWritten" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#waitForBytesWritten">waitForBytesWritten</a>（ ） 。</p>


<h3 class="fn">
<a name="isSequential"></a>bool QAbstractSocket.isSequential (<i>self</i>)</h3>
<p>从重新实现<a href="qiodevice.html#isSequential" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isSequential">QIODevice.isSequential</a>（ ） 。</p>


<h3 class="fn">
<a name="isValid"></a>bool QAbstractSocket.isValid (<i>self</i>)</h3>
<p>返回True如果套接字是有效的，并准备使用，否则返回False 。</p>
<p><b>Note:</b>套接字的状态必须<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">ConnectedState</a>阅读和写作之前可能发生。</p>
<p><b>See also</b> <a href="qabstractsocket.html#state" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#state">state</a>（ ） 。</p>


<h3 class="fn">
<a name="localAddress"></a><a href="qhostaddress.html" tppabs="http://pyqt4doc.appspot.com/qhostaddress.html">QHostAddress</a> QAbstractSocket.localAddress (<i>self</i>)</h3>
<p>返回本地套接字如果可用的主机地址，否则返回<a href="qhostaddress.html#SpecialAddress-enum" tppabs="http://pyqt4doc.appspot.com/qhostaddress.html#SpecialAddress-enum">QHostAddress.Null</a>。</p>
<p>这通常是在主机的主IP地址，但也可以是<a href="qhostaddress.html#SpecialAddress-enum" tppabs="http://pyqt4doc.appspot.com/qhostaddress.html#SpecialAddress-enum">QHostAddress.LocalHost</a>（ 127.0.0.1）来连接到本地主机。</p>
<p><b>See also</b> <a href="qabstractsocket.html#localPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#localPort">localPort</a>（ ）<a href="qabstractsocket.html#peerAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerAddress">peerAddress</a>（）和<a href="qabstractsocket.html#setLocalAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setLocalAddress">setLocalAddress</a>（ ） 。</p>


<h3 class="fn">
<a name="localPort"></a>int QAbstractSocket.localPort (<i>self</i>)</h3>
<p>返回本地套接字如果可用的主机端口号（本地字节顺序） ，否则返回0 。</p>
<p><b>See also</b> <a href="qabstractsocket.html#localAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#localAddress">localAddress</a>（ ）<a href="qabstractsocket.html#peerPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerPort">peerPort</a>（）和<a href="qabstractsocket.html#setLocalPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setLocalPort">setLocalPort</a>（ ） 。</p>


<h3 class="fn">
<a name="peerAddress"></a><a href="qhostaddress.html" tppabs="http://pyqt4doc.appspot.com/qhostaddress.html">QHostAddress</a> QAbstractSocket.peerAddress (<i>self</i>)</h3>
<p>返回所连接的对端的地址，如果套接字是在<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">ConnectedState</a>否则返回<a href="qhostaddress.html#SpecialAddress-enum" tppabs="http://pyqt4doc.appspot.com/qhostaddress.html#SpecialAddress-enum">QHostAddress.Null</a>。</p>
<p><b>See also</b> <a href="qabstractsocket.html#peerName" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerName">peerName</a>（ ）<a href="qabstractsocket.html#peerPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerPort">peerPort</a>（ ）<a href="qabstractsocket.html#localAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#localAddress">localAddress</a>（）和<a href="qabstractsocket.html#setPeerAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setPeerAddress">setPeerAddress</a>（ ） 。</p>


<h3 class="fn">
<a name="peerName"></a>QString QAbstractSocket.peerName (<i>self</i>)</h3>
<p>所指定的返回对端的名称<a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（ ） ，或空<a href="qstring.html" tppabs="http://pyqt4doc.appspot.com/qstring.html">QString</a>如果<a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（ ）尚未被调用。</p>
<p><b>See also</b> <a href="qabstractsocket.html#peerAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerAddress">peerAddress</a>（ ）<a href="qabstractsocket.html#peerPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerPort">peerPort</a>（）和<a href="qabstractsocket.html#setPeerName" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setPeerName">setPeerName</a>（ ） 。</p>


<h3 class="fn">
<a name="peerPort"></a>int QAbstractSocket.peerPort (<i>self</i>)</h3>
<p>返回所连接的对端的端口，如果套接字是在<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">ConnectedState</a>否则返回0 。</p>
<p><b>See also</b> <a href="qabstractsocket.html#peerAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerAddress">peerAddress</a>（ ）<a href="qabstractsocket.html#localPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#localPort">localPort</a>（）和<a href="qabstractsocket.html#setPeerPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setPeerPort">setPeerPort</a>（ ） 。</p>


<h3 class="fn">
<a name="proxy"></a><a href="qnetworkproxy.html" tppabs="http://pyqt4doc.appspot.com/qnetworkproxy.html">QNetworkProxy</a> QAbstractSocket.proxy (<i>self</i>)</h3>
<p>返回此套接字的网络代理。默认情况下，<a href="qnetworkproxy.html#ProxyType-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkproxy.html#ProxyType-enum">QNetworkProxy.DefaultProxy</a>被使用，这意味着该套接字将查询应用程序的默认代理设置。</p>
<p>这个函数是Qt 4.1中引入。</p>
<p><b>See also</b> <a href="qabstractsocket.html#setProxy" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setProxy">setProxy</a>（ ）<a href="qnetworkproxy.html" tppabs="http://pyqt4doc.appspot.com/qnetworkproxy.html">QNetworkProxy</a>和<a href="qnetworkproxyfactory.html" tppabs="http://pyqt4doc.appspot.com/qnetworkproxyfactory.html">QNetworkProxyFactory</a>。</p>


<h3 class="fn">
<a name="readBufferSize"></a>int QAbstractSocket.readBufferSize (<i>self</i>)</h3>
<p>返回内部读缓冲区的大小。这限制了数据的客户端可以在打电话之前收取的金额<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（）或<a href="qiodevice.html#readAll" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readAll">readAll</a>（ ） 。</p>
<p>0读缓冲区的大小（默认值）意味着缓冲区有没有大小限制，以确保数据不会丢失。</p>
<p><b>See also</b> <a href="qabstractsocket.html#setReadBufferSize" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setReadBufferSize">setReadBufferSize</a>（）和<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（ ） 。</p>


<h3 class="fn">
<a name="readData"></a>str QAbstractSocket.readData (<i>self</i>, int <i>maxlen</i>)</h3>
<p>从重新实现<a href="qiodevice.html#readData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readData">QIODevice.readData</a>（ ） 。</p>


<h3 class="fn">
<a name="readLineData"></a>str QAbstractSocket.readLineData (<i>self</i>, int <i>maxlen</i>)</h3>
<p>从重新实现<a href="qiodevice.html#readLineData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLineData">QIODevice.readLineData</a>（ ） 。</p>


<h3 class="fn">
<a name="setLocalAddress"></a>QAbstractSocket.setLocalAddress (<i>self</i>, <a href="qhostaddress.html" tppabs="http://pyqt4doc.appspot.com/qhostaddress.html">QHostAddress</a> <i>address</i>)</h3>
<p>设置到一个连接的本地端的地址<i>address</i>。</p>
<p>您可以在子类中调用这个函数<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>改变的返回值<a href="qabstractsocket.html#localAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#localAddress">localAddress</a>连接后（）函数已经建立。此功能是常用的代理服务器连接虚拟连接设置。</p>
<p>请注意，此功能对套接字的本地地址的连接（例如，之前没有绑定，<a href="qudpsocket.html#bind" tppabs="http://pyqt4doc.appspot.com/qudpsocket.html#bind">QUdpSocket.bind</a>（））。</p>
<p>这个函数是Qt 4.1中引入。</p>
<p><b>See also</b> <a href="qabstractsocket.html#localAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#localAddress">localAddress</a>（ ）<a href="qabstractsocket.html#setLocalPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setLocalPort">setLocalPort</a>（）和<a href="qabstractsocket.html#setPeerAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setPeerAddress">setPeerAddress</a>（ ） 。</p>


<h3 class="fn">
<a name="setLocalPort"></a>QAbstractSocket.setLocalPort (<i>self</i>, int <i>port</i>)</h3>
<p>设置端口上连接的本地端<i>port</i>。</p>
<p>您可以在子类中调用这个函数<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>改变的返回值<a href="qabstractsocket.html#localPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#localPort">localPort</a>连接后（）函数已经建立。此功能是常用的代理服务器连接虚拟连接设置。</p>
<p>请注意，这个函数不套接字的本地端口绑定的连接（如前，<a href="qudpsocket.html#bind" tppabs="http://pyqt4doc.appspot.com/qudpsocket.html#bind">QUdpSocket.bind</a>（））。</p>
<p>这个函数是Qt 4.1中引入。</p>
<p><b>See also</b> <a href="qabstractsocket.html#localPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#localPort">localPort</a>（ ）<a href="qabstractsocket.html#localAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#localAddress">localAddress</a>（ ）<a href="qabstractsocket.html#setLocalAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setLocalAddress">setLocalAddress</a>（）和<a href="qabstractsocket.html#setPeerPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setPeerPort">setPeerPort</a>（ ） 。</p>


<h3 class="fn">
<a name="setPeerAddress"></a>QAbstractSocket.setPeerAddress (<i>self</i>, <a href="qhostaddress.html" tppabs="http://pyqt4doc.appspot.com/qhostaddress.html">QHostAddress</a> <i>address</i>)</h3>
<p>设置连接到的远程端的地址<i>address</i>。</p>
<p>您可以在子类中调用这个函数<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>改变的返回值<a href="qabstractsocket.html#peerAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerAddress">peerAddress</a>连接后（）函数已经建立。此功能是常用的代理服务器连接虚拟连接设置。</p>
<p>这个函数是Qt 4.1中引入。</p>
<p><b>See also</b> <a href="qabstractsocket.html#peerAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerAddress">peerAddress</a>（ ）<a href="qabstractsocket.html#setPeerPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setPeerPort">setPeerPort</a>（）和<a href="qabstractsocket.html#setLocalAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setLocalAddress">setLocalAddress</a>（ ） 。</p>


<h3 class="fn">
<a name="setPeerName"></a>QAbstractSocket.setPeerName (<i>self</i>, QString <i>name</i>)</h3>
<p>设置远端的主机名<i>name</i>。</p>
<p>您可以在子类中调用这个函数<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>改变的返回值<a href="qabstractsocket.html#peerName" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerName">peerName</a>连接后（）函数已经建立。此功能是常用的代理服务器连接虚拟连接设置。</p>
<p>这个函数是Qt 4.1中引入。</p>
<p><b>See also</b> <a href="qabstractsocket.html#peerName" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerName">peerName</a>（ ） 。</p>


<h3 class="fn">
<a name="setPeerPort"></a>QAbstractSocket.setPeerPort (<i>self</i>, int <i>port</i>)</h3>
<p>设置连接到的远程端的端口<i>port</i>。</p>
<p>您可以在子类中调用这个函数<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>改变的返回值<a href="qabstractsocket.html#peerPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerPort">peerPort</a>连接后（）函数已经建立。此功能是常用的代理服务器连接虚拟连接设置。</p>
<p>这个函数是Qt 4.1中引入。</p>
<p><b>See also</b> <a href="qabstractsocket.html#peerPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#peerPort">peerPort</a>（ ）<a href="qabstractsocket.html#setPeerAddress" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setPeerAddress">setPeerAddress</a>（）和<a href="qabstractsocket.html#setLocalPort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setLocalPort">setLocalPort</a>（ ） 。</p>


<h3 class="fn">
<a name="setProxy"></a>QAbstractSocket.setProxy (<i>self</i>, <a href="qnetworkproxy.html" tppabs="http://pyqt4doc.appspot.com/qnetworkproxy.html">QNetworkProxy</a> <i>networkProxy</i>)</h3>
<p>设置此套接字明确网络代理<i>networkProxy</i>。</p>
<p>要禁用使用代理的这个插座，使用<a href="qnetworkproxy.html#ProxyType-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkproxy.html#ProxyType-enum">QNetworkProxy.NoProxy</a>代理类型：</p>
<pre class="cpp">
 socket<span class="operator">-</span><span class="operator">&gt;</span>setProxy(<span class="type"><a href="qnetworkproxy.html" tppabs="http://pyqt4doc.appspot.com/qnetworkproxy.html">QNetworkProxy</a></span><span class="operator">.</span>NoProxy);
</pre>
<p>对于代理的默认值是<a href="qnetworkproxy.html#ProxyType-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkproxy.html#ProxyType-enum">QNetworkProxy.DefaultProxy</a>，这意味着套接字将使用应用程序设置：如果将代理设置QNetworkProxy.setApplicationProxy ，它将使用，否则，如果一个工厂设置QNetworkProxyFactory.setApplicationProxyFactory ，它会查询该工厂类型<a href="qnetworkproxyquery.html#QueryType-enum" tppabs="http://pyqt4doc.appspot.com/qnetworkproxyquery.html#QueryType-enum">QNetworkProxyQuery.TcpSocket</a>。</p>
<p>这个函数是Qt 4.1中引入。</p>
<p><b>See also</b> <a href="qabstractsocket.html#proxy" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#proxy">proxy</a>（ ）<a href="qnetworkproxy.html" tppabs="http://pyqt4doc.appspot.com/qnetworkproxy.html">QNetworkProxy</a>和<a href="qnetworkproxyfactory.html#queryProxy" tppabs="http://pyqt4doc.appspot.com/qnetworkproxyfactory.html#queryProxy">QNetworkProxyFactory.queryProxy</a>（ ） 。</p>


<h3 class="fn">
<a name="setReadBufferSize"></a>QAbstractSocket.setReadBufferSize (<i>self</i>, int <i>size</i>)</h3>
<p>载的大小<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>的内部读缓冲区是<i>size</i>字节。</p>
<p>如果缓冲区大小被限制为一定的大小，<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>将不缓存数据超过此大小。特殊情况下，为0的缓冲区大小意味着读缓存器是无限的，所有输入的数据进行缓冲。这是默认的。</p>
<p>此选项很有用，如果你只在读取特定时间点的数据（例如，在实时流应用程序），或者如果你想保护你的插座对接收的数据过多，最终可能导致应用程序用完内存。</p>
<p>只<a href="qtcpsocket.html" tppabs="http://pyqt4doc.appspot.com/qtcpsocket.html">QTcpSocket</a> uses <a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>的内部缓冲区;<a href="qudpsocket.html" tppabs="http://pyqt4doc.appspot.com/qudpsocket.html">QUdpSocket</a>不使用任何缓冲在所有的，而是依赖于由操作系统提供的隐式缓冲。正因为如此，调用这个函数上<a href="qudpsocket.html" tppabs="http://pyqt4doc.appspot.com/qudpsocket.html">QUdpSocket</a>没有任何影响。</p>
<p><b>See also</b> <a href="qabstractsocket.html#readBufferSize" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#readBufferSize">readBufferSize</a>（）和<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（ ） 。</p>


<h3 class="fn">
<a name="setSocketDescriptor"></a>bool QAbstractSocket.setSocketDescriptor (<i>self</i>, int <i>socketDescriptor</i>, <a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">SocketState</a> <i>state</i> = QAbstractSocket.ConnectedState, <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qiodevice-openmode.html">QIODevice.OpenMode</a> <i>mode</i> = QIODevice.ReadWrite)</h3>
<p>初始化<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>与本地套接字描述符<i>socketDescriptor</i>。返回True如果<i>socketDescriptor</i>被接受为有效的套接字描述符，否则返回False 。该插座是由指定的模式打开<i>openMode</i>，并进入由指定的套接字状态<i>socketState</i>。</p>
<p><b>Note:</b>这是不可能的初始化两个抽象插座，相同的本地套接字描述符。</p>
<p><b>See also</b> <a href="qabstractsocket.html#socketDescriptor" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#socketDescriptor">socketDescriptor</a>（ ） 。</p>


<h3 class="fn">
<a name="setSocketError"></a>QAbstractSocket.setSocketError (<i>self</i>, <a href="qabstractsocket.html#SocketError-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketError-enum">SocketError</a> <i>socketError</i>)</h3>
<p>设置最后对发生错误的类型<i>socketError</i>。</p>
<p><b>See also</b> <a href="qabstractsocket.html#setSocketState" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setSocketState">setSocketState</a>（）和<a href="qiodevice.html#setErrorString" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#setErrorString">setErrorString</a>（ ） 。</p>


<h3 class="fn">
<a name="setSocketOption"></a>QAbstractSocket.setSocketOption (<i>self</i>, <a href="qabstractsocket.html#SocketOption-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketOption-enum">SocketOption</a> <i>option</i>, QVariant <i>value</i>)</h3>
<p>设置给定<i>option</i>由所描述的值<i>value</i>。</p>
<p>此功能被引入Qt的4.6 。</p>
<p><b>See also</b> <a href="qabstractsocket.html#socketOption" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#socketOption">socketOption</a>（ ） 。</p>


<h3 class="fn">
<a name="setSocketState"></a>QAbstractSocket.setSocketState (<i>self</i>, <a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">SocketState</a> <i>state</i>)</h3>
<p>设置套接字的状态，以<i>state</i>。</p>
<p><b>See also</b> <a href="qabstractsocket.html#state" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#state">state</a>（ ） 。</p>


<h3 class="fn">
<a name="socketDescriptor"></a>int QAbstractSocket.socketDescriptor (<i>self</i>)</h3>
<p>返回的本地套接字描述符<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>如果对象是可用的，否则返回-1 。</p>
<p>如果套接字使用<a href="qnetworkproxy.html" tppabs="http://pyqt4doc.appspot.com/qnetworkproxy.html">QNetworkProxy</a>，返回的描述符可能无法与原生socket函数使用。</p>
<p>套接字描述符时，无法使用<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>在<a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">UnconnectedState</a>。</p>
<p><b>See also</b> <a href="qabstractsocket.html#setSocketDescriptor" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setSocketDescriptor">setSocketDescriptor</a>（ ） 。</p>


<h3 class="fn">
<a name="socketOption"></a>QVariant QAbstractSocket.socketOption (<i>self</i>, <a href="qabstractsocket.html#SocketOption-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketOption-enum">SocketOption</a> <i>option</i>)</h3>
<p>返回的值<i>option</i>选项。</p>
<p>此功能被引入Qt的4.6 。</p>
<p><b>See also</b> <a href="qabstractsocket.html#setSocketOption" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#setSocketOption">setSocketOption</a>（ ） 。</p>


<h3 class="fn">
<a name="socketType"></a><a href="qabstractsocket.html#SocketType-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketType-enum">SocketType</a> QAbstractSocket.socketType (<i>self</i>)</h3>
<p>返回套接字的类型（ TCP，UDP或其他） 。</p>
<p><b>See also</b> <a href="qtcpsocket.html" tppabs="http://pyqt4doc.appspot.com/qtcpsocket.html">QTcpSocket</a>和<a href="qudpsocket.html" tppabs="http://pyqt4doc.appspot.com/qudpsocket.html">QUdpSocket</a>。</p>


<h3 class="fn">
<a name="state"></a><a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">SocketState</a> QAbstractSocket.state (<i>self</i>)</h3>
<p>返回套接字的状态。</p>
<p><b>See also</b> <a href="qabstractsocket.html#error" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#error">error</a>（ ） 。</p>


<h3 class="fn">
<a name="waitForBytesWritten"></a>bool QAbstractSocket.waitForBytesWritten (<i>self</i>, int <i>msecs</i> = 30000)</h3>
<p>从重新实现<a href="qiodevice.html#waitForBytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#waitForBytesWritten">QIODevice.waitForBytesWritten</a>（ ） 。</p>


<h3 class="fn">
<a name="waitForConnected"></a>bool QAbstractSocket.waitForConnected (<i>self</i>, int <i>msecs</i> = 30000)</h3>
<p>等待，直到套接字连接，高达<i>msecs</i>毫秒。如果连接已经建立，该函数将返回True，否则返回False 。当它返回False的情况下，你可以调用<a href="qabstractsocket.html#error" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#error">error</a>（）来确定错误的原因。</p>
<p>下面的例子最多等待1秒，以建立连接：</p>
<pre class="cpp">
 socket<span class="operator">-</span><span class="operator">&gt;</span><a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>(<span class="string">"imap"</span><span class="operator">,</span> <span class="number">143</span>);
 <span class="keyword">if</span> (socket<span class="operator">-</span><span class="operator">&gt;</span>waitForConnected(<span class="number">1000</span>))
     <a href="index.htm#qDebug" tppabs="http://pyqt4doc.appspot.com/qtcore.html#qDebug">qDebug</a>(<span class="string">"Connected!"</span>);
</pre>
<p>如果毫秒为-1 ，此功能将不会超时。</p>
<p><b>Note:</b>此功能可能稍长比等待<i>msecs</i>取决于所花费的时间来完成主机查找。</p>
<p><b>Note:</b>多次调用该函数不累积的时间。如果函数超时，连接过程将被中止。</p>
<p><b>See also</b> <a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（）和<a href="qabstractsocket.html#connected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connected">connected</a>（ ） 。</p>


<h3 class="fn">
<a name="waitForDisconnected"></a>bool QAbstractSocket.waitForDisconnected (<i>self</i>, int <i>msecs</i> = 30000)</h3>
<p>等待，直到插座断开连接，直至<i>msecs</i>毫秒。如果连接已经断开，则该函数返回True，否则返回False 。当它返回False的情况下，你可以调用<a href="qabstractsocket.html#error" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#error">error</a>（）来确定错误的原因。</p>
<p>下面的例子最多等待一秒钟的连接被关闭：</p>
<pre class="cpp">
 socket<span class="operator">-</span><span class="operator">&gt;</span><a href="qabstractsocket.html#disconnectFromHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>();
     <span class="keyword">if</span> (socket<span class="operator">-</span><span class="operator">&gt;</span>state() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a></span><span class="operator">.</span>UnconnectedState <span class="operator">|</span><span class="operator">|</span>
         socket<span class="operator">-</span><span class="operator">&gt;</span>waitForDisconnected(<span class="number">1000</span>))
         <a href="index.htm#qDebug" tppabs="http://pyqt4doc.appspot.com/qtcore.html#qDebug">qDebug</a>(<span class="string">"Disconnected!"</span>);
</pre>
<p>如果毫秒为-1 ，此功能将不会超时。</p>
<p><b>See also</b> <a href="qabstractsocket.html#disconnectFromHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>（）和<a href="qabstractsocket.html#close" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#close">close</a>（ ） 。</p>


<h3 class="fn">
<a name="waitForReadyRead"></a>bool QAbstractSocket.waitForReadyRead (<i>self</i>, int <i>msecs</i> = 30000)</h3>
<p>从重新实现<a href="qiodevice.html#waitForReadyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#waitForReadyRead">QIODevice.waitForReadyRead</a>（ ） 。</p>
<p>此功能块，直到新的数据可供读取和<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead()</a>信号已经发出。之后，该函数将超时<i>msecs</i>毫秒，默认的超时时间为30000毫秒。</p>
<p>该函数返回True，如果<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（ ）信号被发射，并有可供读取新数据，否则返回False （如果发生错误或者操作超时） 。</p>
<p><b>See also</b> <a href="qabstractsocket.html#waitForBytesWritten" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#waitForBytesWritten">waitForBytesWritten</a>（ ） 。</p>


<h3 class="fn">
<a name="writeData"></a>int QAbstractSocket.writeData (<i>self</i>, str <i>data</i>)</h3>
<p>从重新实现<a href="qiodevice.html#writeData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#writeData">QIODevice.writeData</a>（ ） 。</p>
<hr>
<h2>Qt Signal Documentation</h2>
<h3 class="fn">
<a name="connected"></a>void connected ()</h3>
<p>这是该信号的默认超载。</p>
<p>之后此信号被发射<a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（ ）被调用，并连接已成功建立。</p>
<p><b>Note:</b>在一些操作系统上的连接（）信号可以直接从所发射的<a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（ ）调用来连接到本地主机。</p>
<p><b>See also</b> <a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（）和<a href="qabstractsocket.html#disconnected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnected">disconnected</a>（ ） 。</p>


<h3 class="fn">
<a name="disconnected"></a>void disconnected ()</h3>
<p>这是该信号的默认超载。</p>
<p>当插座已断开这个信号被发射。</p>
<p><b>Warning:</b>如果您需要删除<a href="qobject.html#sender" tppabs="http://pyqt4doc.appspot.com/qobject.html#sender">sender</a>在连接到它的插槽这个信号的（ ） ，请使用<a href="qobject.html#deleteLater" tppabs="http://pyqt4doc.appspot.com/qobject.html#deleteLater">deleteLater()</a>功能。</p>
<p><b>See also</b> <a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（ ）<a href="qabstractsocket.html#disconnectFromHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#disconnectFromHost">disconnectFromHost</a>（）和<a href="qabstractsocket.html#abort" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#abort">abort</a>（ ） 。</p>


<h3 class="fn">
<a name="error-2"></a>void error (QAbstractSocket::SocketError)</h3>
<p>这是该信号的默认超载。</p>
<p>这个信号被发射时发生错误之后。该<i>socketError</i>参数描述发生错误的类型。</p>
<p><a href="qabstractsocket.html#SocketError-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketError-enum">QAbstractSocket.SocketError</a>是不是注册的元类型，所以排队的连接，你将不得不用它注册<a href="qmetatype.html#Q_DECLARE_METATYPE" tppabs="http://pyqt4doc.appspot.com/qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>（）和<a href="qmetatype.html#qRegisterMetaType" tppabs="http://pyqt4doc.appspot.com/qmetatype.html#qRegisterMetaType">qRegisterMetaType</a>（ ） 。</p>
<p><b>See also</b> <a href="qabstractsocket.html#error" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#error">error</a>（ ）<a href="qiodevice.html#errorString" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#errorString">errorString</a>（）和<a href="index.htm" tppabs="http://pyqt4doc.appspot.com/custom-types.html">Creating Custom Qt Types</a>。</p>


<h3 class="fn">
<a name="hostFound"></a>void hostFound ()</h3>
<p>这是该信号的默认超载。</p>
<p>之后此信号被发射<a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（ ）被调用并且主机查找成功。</p>
<p><b>Note:</b>由于Qt的4.6.3<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>可以从发射hostFound （）直接<a href="qabstractsocket.html#connectToHost" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connectToHost">connectToHost</a>（ ）调用，因为一个DNS结果可能已经被缓存。</p>
<p><b>See also</b> <a href="qabstractsocket.html#connected" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#connected">connected</a>（ ） 。</p>


<h3 class="fn">
<a name="proxyAuthenticationRequired"></a>void proxyAuthenticationRequired (const QNetworkProxy&amp;,QAuthenticator *)</h3>
<p>这是该信号的默认超载。</p>
<p>这个信号可以被发射时，一<i>proxy</i>需要进行身份验证时使用。该<i>authenticator</i>对象可以被填充在与必需的细节，以便验证和持续的连接。</p>
<p><b>Note:</b>这是不可能使用QueuedConnection连接到该信号，就好像所述认证没有被填充了新的信息时，该信号返回的连接失败。</p>
<p>此功能被引入Qt的4.3 。</p>
<p><b>See also</b> <a href="qauthenticator.html" tppabs="http://pyqt4doc.appspot.com/qauthenticator.html">QAuthenticator</a>和<a href="qnetworkproxy.html" tppabs="http://pyqt4doc.appspot.com/qnetworkproxy.html">QNetworkProxy</a>。</p>


<h3 class="fn">
<a name="stateChanged"></a>void stateChanged (QAbstractSocket::SocketState)</h3>
<p>这是该信号的默认超载。</p>
<p>这个信号被发射时<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>的状态变化。该<i>socketState</i>参数是新的状态。</p>
<p><a href="qabstractsocket.html#SocketState-enum" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#SocketState-enum">QAbstractSocket.SocketState</a>是不是注册的元类型，所以排队的连接，你将不得不与Q_REGISTER_METATYPE （注册它）和<a href="qmetatype.html#qRegisterMetaType" tppabs="http://pyqt4doc.appspot.com/qmetatype.html#qRegisterMetaType">qRegisterMetaType</a>（ ） 。</p>
<p><b>See also</b> <a href="qabstractsocket.html#state" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html#state">state</a>（）和<a href="index.htm" tppabs="http://pyqt4doc.appspot.com/custom-types.html">Creating Custom Qt Types</a>。</p>


<address>
<div class="ad">
<br> 
<br><hr>
</div>
<div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address">
<td align="left" width="25%">PyQt 4.10.3 for X11</td>
<td align="center" width="50%">Copyright © <a href="http://www.riverbankcomputing.com/">Riverbank Computing Ltd</a> and <a href="http://www.qtsoftware.com/">Nokia</a> 2012</td>
<td align="right" width="25%">Qt 4.8.5</td>
</tr></table></div>
</address>
</body>
</html>