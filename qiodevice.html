<html>
<head>
<title>QIODevice Class Reference</title>
<style>h3.fn,span.fn { margin-left: 1cm; text-indent: -1cm }
a:link { color: #004faf; text-decoration: none }
a:visited { color: #672967; text-decoration: none }
td.postheader { font-family: sans-serif }
tr.address { font-family: sans-serif }
body { background: #ffffff; color: black; }
</style>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr></tr>
<td align="left" valign="top" width="32"><img align="left" border="0" height="32" src="images/rb-logo.png" tppabs="http://pyqt4doc.appspot.com/images/rb-logo.png" width="32"></td>
<td width="1">  </td>
<td class="postheader" valign="center">
<a href="index.html" tppabs="http://pyqt4doc.appspot.com/index.html"><font color="#004faf">Home</font></a> · <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/classes.html"><font color="#004faf">All Classes</font></a> · <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/modules.html"><font color="#004faf">Modules</font></a>  · <a href="qss.html"><font color="#004faf">QSS HELP</font></a>  · <a href="qtqss.html"><font color="#004faf">QSS 案例</font></a> · <a href="HTTP://VER007.COM"><font color="#004faf">VER007 HOME</font></a> 
</td>
</table>
<h1 align="center">QIODevice Class Reference<br><sup><sup>[<a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qtcore.html">QtCore</a> module]</sup></sup>
</h1>
<p>The QIODevice class is the base interface class of all I/O
devices in Qt. <a href="#details">More...</a></p>

<p>继承<a href="qobject.html" tppabs="http://pyqt4doc.appspot.com/qobject.html">QObject</a>。</p>
<p>通过继承<a href="qabstractsocket.html" tppabs="http://pyqt4doc.appspot.com/qabstractsocket.html">QAbstractSocket</a>，<a href="qbuffer.html" tppabs="http://pyqt4doc.appspot.com/qbuffer.html">QBuffer</a>，<a href="qfile.html" tppabs="http://pyqt4doc.appspot.com/qfile.html">QFile</a>，<a href="qlocalsocket.html" tppabs="http://pyqt4doc.appspot.com/qlocalsocket.html">QLocalSocket</a>，<a href="qnetworkreply.html" tppabs="http://pyqt4doc.appspot.com/qnetworkreply.html">QNetworkReply</a>和<a href="qprocess.html" tppabs="http://pyqt4doc.appspot.com/qprocess.html">QProcess</a>。</p>
<h3>Types</h3>
<ul>
<li>
<div class="fn"></div>class <b><a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qiodevice-openmode.html">OpenMode</a></b>
</li>
<li>
<div class="fn"></div>enum <b><a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenModeFlag</a></b> { NotOpen, ReadOnly, WriteOnly, ReadWrite, ..., Unbuffered }</li>
</ul>
<h3>Methods</h3>
<ul>
<li>
<div class="fn"></div>
<b><a href="qiodevice.html#QIODevice" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#QIODevice">__init__</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qiodevice.html#QIODevice-2" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#QIODevice-2">__init__</a></b> (<i>self</i>, QObject <i>parent</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qiodevice.html#atEnd" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#atEnd">atEnd</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qiodevice.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesAvailable">bytesAvailable</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qiodevice.html#bytesToWrite" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesToWrite">bytesToWrite</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qiodevice.html#canReadLine" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#canReadLine">canReadLine</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qiodevice.html#close" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#close">close</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QString <b><a href="qiodevice.html#errorString" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#errorString">errorString</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>(bool, str <i>c</i>) <b><a href="qiodevice.html#getChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#getChar">getChar</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qiodevice.html#isOpen" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isOpen">isOpen</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qiodevice.html#isReadable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isReadable">isReadable</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qiodevice.html#isSequential" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isSequential">isSequential</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qiodevice.html#isTextModeEnabled" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isTextModeEnabled">isTextModeEnabled</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qiodevice.html#isWritable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isWritable">isWritable</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qiodevice.html#open" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#open">open</a></b> (<i>self</i>, OpenMode <i>mode</i>)</li>
<li>
<div class="fn"></div>OpenMode <b><a href="qiodevice.html#openMode" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#openMode">openMode</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>QByteArray <b><a href="qiodevice.html#peek" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#peek">peek</a></b> (<i>self</i>, int <i>maxlen</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qiodevice.html#pos" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#pos">pos</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qiodevice.html#putChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#putChar">putChar</a></b> (<i>self</i>, str <i>c</i>)</li>
<li>
<div class="fn"></div>str <b><a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a></b> (<i>self</i>, int <i>maxlen</i>)</li>
<li>
<div class="fn"></div>QByteArray <b><a href="qiodevice.html#readAll" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readAll">readAll</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>str <b><a href="qiodevice.html#readData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readData">readData</a></b> (<i>self</i>, int <i>maxlen</i>)</li>
<li>
<div class="fn"></div>str <b><a href="qiodevice.html#readLine" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLine">readLine</a></b> (<i>self</i>, int <i>maxlen</i> = 0)</li>
<li>
<div class="fn"></div>str <b><a href="qiodevice.html#readLineData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLineData">readLineData</a></b> (<i>self</i>, int <i>maxlen</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qiodevice.html#reset" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#reset">reset</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qiodevice.html#seek" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#seek">seek</a></b> (<i>self</i>, int <i>pos</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qiodevice.html#setErrorString" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#setErrorString">setErrorString</a></b> (<i>self</i>, QString <i>errorString</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qiodevice.html#setOpenMode" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#setOpenMode">setOpenMode</a></b> (<i>self</i>, OpenMode <i>openMode</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qiodevice.html#setTextModeEnabled" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#setTextModeEnabled">setTextModeEnabled</a></b> (<i>self</i>, bool <i>enabled</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qiodevice.html#size" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#size">size</a></b> (<i>self</i>)</li>
<li>
<div class="fn"></div>
<b><a href="qiodevice.html#ungetChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#ungetChar">ungetChar</a></b> (<i>self</i>, str <i>c</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qiodevice.html#waitForBytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#waitForBytesWritten">waitForBytesWritten</a></b> (<i>self</i>, int <i>msecs</i>)</li>
<li>
<div class="fn"></div>bool <b><a href="qiodevice.html#waitForReadyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#waitForReadyRead">waitForReadyRead</a></b> (<i>self</i>, int <i>msecs</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qiodevice.html#write" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#write">write</a></b> (<i>self</i>, QByteArray <i>data</i>)</li>
<li>
<div class="fn"></div>int <b><a href="qiodevice.html#writeData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#writeData">writeData</a></b> (<i>self</i>, str <i>data</i>)</li>
</ul>
<h3>Qt Signals</h3>
<ul>
<li>
<div class="fn"></div>void <b><a href="qiodevice.html#aboutToClose" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#aboutToClose">aboutToClose</a></b> ()</li>
<li>
<div class="fn"></div>void <b><a href="qiodevice.html#bytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesWritten">bytesWritten</a></b> (qint64)</li>
<li>
<div class="fn"></div>void <b><a href="qiodevice.html#readChannelFinished" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readChannelFinished">readChannelFinished</a></b> ()</li>
<li>
<div class="fn"></div>void <b><a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a></b> ()</li>
</ul>
<a name="details"></a><div class="ad">
<hr>
 
</div>
<h2>Detailed Description</h2>
<p>该QIODevice中类是Qt中所有的I / O设备的基本接口类。</p>
<p>QIODevice中提供了一个通用的实现和抽象接口用于支持读数据块，写装置，如<a href="qfile.html" tppabs="http://pyqt4doc.appspot.com/qfile.html">QFile</a>，<a href="qbuffer.html" tppabs="http://pyqt4doc.appspot.com/qbuffer.html">QBuffer</a>和<a href="qtcpsocket.html" tppabs="http://pyqt4doc.appspot.com/qtcpsocket.html">QTcpSocket</a>。 QIODevice中是抽象的，并且不能被实例化，但是通常使用它定义提供设备无关的I / O特性的接口。例如， Qt的XML类上的QIODevice指针操作，使他们能够与各种设备（如文件和缓冲区）使用。</p>
<p>访问该设备之前，<a href="qiodevice.html#open" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#open">open</a>（ ）必须被调用来设置正确的<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenMode</a>（如<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">ReadOnly</a> or <a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">ReadWrite</a>） 。然后，您可以写信给装置<a href="qiodevice.html#write" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#write">write</a>（）或<a href="qiodevice.html#putChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#putChar">putChar</a>（ ） ，并宣读通过调用<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（ ）<a href="qiodevice.html#readLine" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLine">readLine</a>（） ，或<a href="qiodevice.html#readAll" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readAll">readAll</a>（ ） 。通话<a href="qiodevice.html#close" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#close">close</a>（）当你的设备完成的。</p>
<p>随机存取设备和顺序装置：两种类型的设备之间的QIODevice区分。</p>
<ul>
<li>Random-access devices support seeking to arbitrary positions
using <a href="qiodevice.html#seek" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#seek">seek</a>(). The current
position in the file is available by calling <a href="qiodevice.html#pos" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#pos">pos</a>(). <a href="qfile.html" tppabs="http://pyqt4doc.appspot.com/qfile.html">QFile</a> and
<a href="qbuffer.html" tppabs="http://pyqt4doc.appspot.com/qbuffer.html">QBuffer</a> are examples of random-access
devices.</li>
<li>Sequential devices don't support seeking to arbitrary
positions. The data must be read in one pass. The functions
<a href="qiodevice.html#pos" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#pos">pos</a>() and <a href="qiodevice.html#size" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#size">size</a>() don't work for sequential devices.
<a href="qtcpsocket.html" tppabs="http://pyqt4doc.appspot.com/qtcpsocket.html">QTcpSocket</a> and <a href="qprocess.html" tppabs="http://pyqt4doc.appspot.com/qprocess.html">QProcess</a> are examples of sequential
devices.</li>
</ul>
<p>您可以使用<a href="qiodevice.html#isSequential" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isSequential">isSequential</a>（）来确定设备的类型。</p>
<p>QIODevice中发出<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（ ）当新的数据可供读取，例如，如果新数据到达网络上，或者额外的数据附加到正在读取的文件。您可以致电<a href="qiodevice.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesAvailable">bytesAvailable</a>（ ）来确定当前可用来读取的字节数。这是常见的使用<a href="qiodevice.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesAvailable">bytesAvailable</a>（）连同<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（）信号与异步设备，如编程<a href="qtcpsocket.html" tppabs="http://pyqt4doc.appspot.com/qtcpsocket.html">QTcpSocket</a>其中数据的片段可以在时间的任意时刻到达。 QIODevice中放出<a href="qiodevice.html#bytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesWritten">bytesWritten</a>（）信号的每一个数据的有效载荷中已被写入到该设备的时间。使用<a href="qiodevice.html#bytesToWrite" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesToWrite">bytesToWrite</a>（）来确定数据等待写入的电流量。</p>
<p>QIODevice中的某些亚类，如<a href="qtcpsocket.html" tppabs="http://pyqt4doc.appspot.com/qtcpsocket.html">QTcpSocket</a>和<a href="qprocess.html" tppabs="http://pyqt4doc.appspot.com/qprocess.html">QProcess</a>，是异步的。这意味着， I / O功能，如<a href="qiodevice.html#write" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#write">write</a>（）或<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（ ）总是立刻返回，而当控制返回到事件循环与设备本身的通信可能发生。 QIODevice中提供的功能，让您可以强制这些操作必须立即执行的，而阻塞调用线程，并没有进入事件循环。这允许用户在没有事件循环，或者在单独的线程中使用的QIODevice子类：</p>
<ul>
<li>
<a href="qiodevice.html#waitForReadyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#waitForReadyRead">waitForReadyRead</a>() - This
function suspends operation in the calling thread until new data is
available for reading.</li>
<li>
<a href="qiodevice.html#waitForBytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#waitForBytesWritten">waitForBytesWritten</a>() -
This function suspends operation in the calling thread until one
payload of data has been written to the device.</li>
<li>waitFor....() - Subclasses of QIODevice implement blocking
functions for device-specific operations. For example, <a href="qprocess.html" tppabs="http://pyqt4doc.appspot.com/qprocess.html">QProcess</a> has a function called waitForStarted()
which suspends operation in the calling thread until the process
has started.</li>
</ul>
<p>从主， GUI线程中调用这些功能，可能会导致你的用户界面冻结。例如：</p>
<pre class="cpp">
 <span class="type"><a href="qprocess.html" tppabs="http://pyqt4doc.appspot.com/qprocess.html">QProcess</a></span> gzip;
 gzip<span class="operator">.</span>start(<span class="string">"gzip"</span><span class="operator">,</span> <span class="type"><a href="qstringlist.html" tppabs="http://pyqt4doc.appspot.com/qstringlist.html">QStringList</a></span>() <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">"-c"</span>);
 <span class="keyword">if</span> (<span class="operator">!</span>gzip<span class="operator">.</span>waitForStarted())
     <span class="keyword">return</span> <span class="keyword">false</span>;

 gzip<span class="operator">.</span><a href="qiodevice.html#write" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#write">write</a>(<span class="string">"uncompressed data"</span>);

 <span class="type"><a href="qbytearray.html" tppabs="http://pyqt4doc.appspot.com/qbytearray.html">QByteArray</a></span> compressed;
 <span class="keyword">while</span> (gzip<span class="operator">.</span>waitForReadyRead())
     compressed <span class="operator">+</span><span class="operator">=</span> gzip<span class="operator">.</span><a href="qiodevice.html#readAll" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readAll">readAll</a>();
</pre>
<p>通过子类QIODevice中，您可以提供相同的接口，以你自己的I / O设备。 QIODevice中的子类来实现保护时，才需要<a href="qiodevice.html#readData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readData">readData</a>（）和<a href="qiodevice.html#writeData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#writeData">writeData</a>（）函数。 QIODevice中使用这些函数执行所有它的便利功能，如<a href="qiodevice.html#getChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#getChar">getChar</a>（ ）<a href="qiodevice.html#readLine" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLine">readLine</a>（）和<a href="qiodevice.html#write" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#write">write</a>（ ） 。 QIODevice中还为您处理访问控制，这样你就可以安全地假定该设备在写模式打开，如果<a href="qiodevice.html#writeData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#writeData">writeData</a>（）被调用。</p>
<p>一些子类，如<a href="qfile.html" tppabs="http://pyqt4doc.appspot.com/qfile.html">QFile</a>和<a href="qtcpsocket.html" tppabs="http://pyqt4doc.appspot.com/qtcpsocket.html">QTcpSocket</a>，使用的内存缓冲区用于数据的中间存储实现。这减少了所需的设备访问调用，这通常是非常慢的数量。使缓冲功能，如<a href="qiodevice.html#getChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#getChar">getChar</a>（）和<a href="qiodevice.html#putChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#putChar">putChar</a>（）快，因为它们可以在设备本身上的存储器缓冲操作，而不是直接。某些I / O操作，但是，不具有缓冲工作。例如，如果多个用户打开相同的设备和由字符阅读的字符，它们最终可能读取相同的数据时，为了读取一个单独的组块的每个。出于这个原因， QIODevice中允许你通过将无缓冲标志来绕过任何缓冲<a href="qiodevice.html#open" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#open">open</a>（ ） 。当继承了QIODevice ，记得要绕过你可以使用时，设备处于无缓冲模式打开的任何缓冲区。</p>
<hr>
<h2>Type Documentation</h2>
<h3 class="fn">
<a name="OpenModeFlag-enum"></a>QIODevice.OpenModeFlag</h3>
<p>此枚举是使用<a href="qiodevice.html#open" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#open">open</a>（ ）来描述，其中一个装置被打开的模式。它也被返回<a href="qiodevice.html#openMode" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#openMode">openMode</a>（ ） 。</p>
<table class="valuelist">
<tr class="odd" valign="top">
<th class="tblConst">Constant</th>
<th class="tblval">Value</th>
<th class="tbldscr">Description</th>
</tr>
<tr>
<td class="topAlign"><tt>QIODevice.NotOpen</tt></td>
<td class="topAlign"><tt>0x0000</tt></td>
<td class="topAlign">该设备未打开。</td>
</tr>
<tr>
<td class="topAlign"><tt>QIODevice.ReadOnly</tt></td>
<td class="topAlign"><tt>0x0001</tt></td>
<td class="topAlign">该设备是开放式的阅读。</td>
</tr>
<tr>
<td class="topAlign"><tt>QIODevice.WriteOnly</tt></td>
<td class="topAlign"><tt>0x0002</tt></td>
<td class="topAlign">该设备是开放式的写作。</td>
</tr>
<tr>
<td class="topAlign"><tt>QIODevice.ReadWrite</tt></td>
<td class="topAlign"><tt>ReadOnly | WriteOnly</tt></td>
<td class="topAlign">该设备是开放式的阅读和写作。</td>
</tr>
<tr>
<td class="topAlign"><tt>QIODevice.Append</tt></td>
<td class="topAlign"><tt>0x0004</tt></td>
<td class="topAlign">该器件采用追加模式打开，让所有的数据写入到文件的末尾。</td>
</tr>
<tr>
<td class="topAlign"><tt>QIODevice.Truncate</tt></td>
<td class="topAlign"><tt>0x0008</tt></td>
<td class="topAlign">如果可能的话，该装置被打开之前被截断。该设备的所有早期的内容会丢失。</td>
</tr>
<tr>
<td class="topAlign"><tt>QIODevice.Text</tt></td>
<td class="topAlign"><tt>0x0010</tt></td>
<td class="topAlign">阅读时，行尾的终结被翻译成的'\ n ' 。写作时，行尾的终结将被转换为本地编码，例如' \ r \ ñ'为Win32 。</td>
</tr>
<tr>
<td class="topAlign"><tt>QIODevice.Unbuffered</tt></td>
<td class="topAlign"><tt>0x0020</tt></td>
<td class="topAlign">任何缓冲设备中被绕过。</td>
</tr>
</table>
<p>某些标志，如<tt>Unbuffered</tt>和<tt>Truncate</tt>一些子类中使用时，是没有意义的。其中的一些限制是由器件的是由子类所表示的类型暗示。在其他情况下，该限制可能是由于在实施方式中，或者可以通过对底层平台的罚款;例如<a href="qtcpsocket.html" tppabs="http://pyqt4doc.appspot.com/qtcpsocket.html">QTcpSocket</a>不支持<tt>Unbuffered</tt>模式，和本机API中的限制阻止<a href="qfile.html" tppabs="http://pyqt4doc.appspot.com/qfile.html">QFile</a>从支持<tt>Unbuffered</tt>在Windows上。</p>
<p>为openMode类型是一个typedef为<a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qflags.html">QFlags</a>\u003cOpenModeFlag\u003e 。它存储OpenModeFlag值的或组合。</p>
<hr>
<h2>Method Documentation</h2>
<h3 class="fn">
<a name="QIODevice"></a>QIODevice.__init__ (<i>self</i>)</h3>
<p>构造一个<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>对象。</p>


<h3 class="fn">
<a name="QIODevice-2"></a>QIODevice.__init__ (<i>self</i>, <a href="qobject.html" tppabs="http://pyqt4doc.appspot.com/qobject.html">QObject</a> <i>parent</i>)</h3>
<p>该<i>parent</i>的说法，如果不是没有，原因<i>self</i>通过Qt的，而不是PyQt的拥有。</p>
<p>构造一个<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>与给定对象<i>parent</i>。</p>


<h3 class="fn">
<a name="atEnd"></a>bool QIODevice.atEnd (<i>self</i>)</h3>
<p>返回True如果当前读写位置是在设备上（即没有可用于读取设备上没有更多的数据）的末尾，否则返回False 。</p>
<p>对于某些设备，了atEnd （ ）可以返回True ，即使有更多的数据读取。这种特殊的情况下只适用于产生直接回应你打电话数据设备<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（ ）（例如，<tt>/dev</tt> or
<tt>/proc</tt>在Unix和Mac OS X的文件，或者控制台输入/<tt>stdin</tt>在所有平台） 。</p>
<p><b>See also</b> <a href="qiodevice.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesAvailable">bytesAvailable</a>（ ）<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（）和<a href="qiodevice.html#isSequential" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isSequential">isSequential</a>（ ） 。</p>


<h3 class="fn">
<a name="bytesAvailable"></a>int QIODevice.bytesAvailable (<i>self</i>)</h3>
<p>返回可用于读出的字节数。这个函数是常用的使用顺序的设备，以确定的字节数读数之前在缓冲器中分配。</p>
<p>即重新实现这个函数的子类必须调用为了基实现，以包括QIODevices '缓冲区的大小。例如：</p>
<pre class="cpp">
 <span class="type"><a href="index.htm#qint64-typedef" tppabs="http://pyqt4doc.appspot.com/qtcore.html#qint64-typedef">long</a></span> CustomDevice<span class="operator">.</span>bytesAvailable() <span class="keyword">const</span>
 {
     <span class="keyword">return</span> buffer<span class="operator">.</span>size() <span class="operator">+</span> <span class="type"><a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a></span><span class="operator">.</span>bytesAvailable();
 }
</pre>
<p><b>See also</b> <a href="qiodevice.html#bytesToWrite" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesToWrite">bytesToWrite</a>（ ）<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（）和<a href="qiodevice.html#isSequential" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isSequential">isSequential</a>（ ） 。</p>


<h3 class="fn">
<a name="bytesToWrite"></a>int QIODevice.bytesToWrite (<i>self</i>)</h3>
<p>对于缓冲装置，该函数返回字节等待写入的数量。对于没有缓冲装置，该函数返回0 。</p>
<p><b>See also</b> <a href="qiodevice.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesAvailable">bytesAvailable</a>（ ）<a href="qiodevice.html#bytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesWritten">bytesWritten</a>（）和<a href="qiodevice.html#isSequential" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isSequential">isSequential</a>（ ） 。</p>


<h3 class="fn">
<a name="canReadLine"></a>bool QIODevice.canReadLine (<i>self</i>)</h3>
<p>返回True如果一个完整的数据线可以从设备中读取，否则返回False 。</p>
<p>需要注意的是缓冲装置，这也没有办法确定哪些可以读取，总是返回False 。</p>
<p>这个功能通常被称为与结合<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（）信号。</p>
<p>即重新实现这个函数的子类必须调用基实现，以包括的内容<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>的缓冲。例如：</p>
<pre class="cpp">
 <span class="type">bool</span> CustomDevice<span class="operator">.</span>canReadLine() <span class="keyword">const</span>
 {
     <span class="keyword">return</span> buffer<span class="operator">.</span>contains(<span class="char">'\n'</span>) <span class="operator">|</span><span class="operator">|</span> <span class="type"><a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a></span><span class="operator">.</span>canReadLine();
 }
</pre>
<p><b>See also</b> <a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（）和<a href="qiodevice.html#readLine" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLine">readLine</a>（ ） 。</p>


<h3 class="fn">
<a name="close"></a>QIODevice.close (<i>self</i>)</h3>
<p>首先发出<a href="qiodevice.html#aboutToClose" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#aboutToClose">aboutToClose</a>（） ，然后关闭该装置，并将其<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenMode</a>至<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">NotOpen</a>。错误字符串也被重置。</p>
<p><b>See also</b> <a href="qiodevice.html#setOpenMode" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#setOpenMode">setOpenMode</a>（）和<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenMode</a>。</p>


<h3 class="fn">
<a name="errorString"></a>QString QIODevice.errorString (<i>self</i>)</h3>
<p>返回上次发生设备错误的人类可读的描述。</p>
<p><b>See also</b> <a href="qiodevice.html#setErrorString" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#setErrorString">setErrorString</a>（ ） 。</p>


<h3 class="fn">
<a name="getChar"></a>(bool, str <i>c</i>) QIODevice.getChar (<i>self</i>)</h3>
<p>读取从设备并将其存储在一个字符<i>c</i>。如果<i>c</i>是0时，字符被丢弃。成功时返回TRUE ，否则返回False 。</p>
<p><b>See also</b> <a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（ ）<a href="qiodevice.html#putChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#putChar">putChar</a>（）和<a href="qiodevice.html#ungetChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#ungetChar">ungetChar</a>（ ） 。</p>


<h3 class="fn">
<a name="isOpen"></a>bool QIODevice.isOpen (<i>self</i>)</h3>
<p>返回True如果该设备已打开，否则返回False 。设备是开放的，如果它可以读取和/或写入。默认情况下，这个函数返回False ，如果<a href="qiodevice.html#openMode" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#openMode">openMode</a>（）返回<tt>NotOpen</tt>。</p>
<p><b>See also</b> <a href="qiodevice.html#openMode" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#openMode">openMode</a>（）和<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenMode</a>。</p>


<h3 class="fn">
<a name="isReadable"></a>bool QIODevice.isReadable (<i>self</i>)</h3>
<p>返回True如果数据可以从设备读取，否则返回False 。使用<a href="qiodevice.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesAvailable">bytesAvailable</a>（）来确定多少字节可以被读取。</p>
<p>这是一个方便的功能，如果它检查<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenMode</a>该装置包含<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">ReadOnly</a>标志。</p>
<p><b>See also</b> <a href="qiodevice.html#openMode" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#openMode">openMode</a>（）和<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenMode</a>。</p>


<h3 class="fn">
<a name="isSequential"></a>bool QIODevice.isSequential (<i>self</i>)</h3>
<p>返回True如果该设备是连续的，否则返回False 。</p>
<p>连续的设备，而不是一个随机存取设备，还没有任何概念的一个开始，结束，大小，或当前位置，并且它们不支持寻求。您只能从设备读取时，它报告的数据是可用的。顺序设备的最常见的例子是网络套接字。在Unix上，特殊文件如/ dev / zero的和FIFO管道是连续的。</p>
<p>常规文件，另一方面，也支持随机访问。它们既具有大小和当前位置，并且它们还支持寻求向后和向前的数据流中。普通文件是不连续的。</p>
<p>该<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>实现返回False 。</p>
<p><b>See also</b> <a href="qiodevice.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesAvailable">bytesAvailable</a>（ ） 。</p>


<h3 class="fn">
<a name="isTextModeEnabled"></a>bool QIODevice.isTextModeEnabled (<i>self</i>)</h3>
<p>返回True如果<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">Text</a>标志为启用，否则返回False 。</p>
<p><b>See also</b> <a href="qiodevice.html#setTextModeEnabled" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#setTextModeEnabled">setTextModeEnabled</a>（ ） 。</p>


<h3 class="fn">
<a name="isWritable"></a>bool QIODevice.isWritable (<i>self</i>)</h3>
<p>返回True如果数据可以被写入到该设备，否则返回False 。</p>
<p>这是一个方便的功能，如果它检查<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenMode</a>该装置包含<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">WriteOnly</a>标志。</p>
<p><b>See also</b> <a href="qiodevice.html#openMode" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#openMode">openMode</a>（）和<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenMode</a>。</p>


<h3 class="fn">
<a name="open"></a>bool QIODevice.open (<i>self</i>, <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qiodevice-openmode.html">OpenMode</a> <i>mode</i>)</h3>
<p>打开该设备，并将其<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenMode</a>至<i>mode</i>。成功返回True ，否则返回False 。这个函数应该被称为从open（）或其他函数打开设备的任何重新实现。</p>
<p><b>See also</b> <a href="qiodevice.html#openMode" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#openMode">openMode</a>（）和<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenMode</a>。</p>


<h3 class="fn">
<a name="openMode"></a><a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qiodevice-openmode.html">OpenMode</a> QIODevice.openMode (<i>self</i>)</h3>
<p>返回在该设备已被打开的模式，即<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">ReadOnly</a> or <a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">WriteOnly</a>。</p>
<p><b>See also</b> <a href="qiodevice.html#setOpenMode" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#setOpenMode">setOpenMode</a>（）和<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenMode</a>。</p>


<h3 class="fn">
<a name="peek"></a><a href="qbytearray.html" tppabs="http://pyqt4doc.appspot.com/qbytearray.html">QByteArray</a> QIODevice.peek (<i>self</i>, int <i>maxlen</i>)</h3>
<p>阅读次数最多<i>maxSize</i>从设备到字节<i>data</i>，无副作用（即，如果你调用<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（ ） PEEK （）之后，您将获得相同的数据） 。返回读取的字节数。如果发生错误，企图偷看在打开设备时，如<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">WriteOnly</a>模式下，该函数返回-1 。</p>
<p>当没有更多的数据可供读取返回0。</p>
<p>例如：</p>
<pre class="cpp">
 <span class="type">bool</span> isExeFile(<span class="type"><a href="qfile.html" tppabs="http://pyqt4doc.appspot.com/qfile.html">QFile</a></span> <span class="operator">*</span>file)
 {
     <span class="type">char</span> buf<span class="operator">[</span><span class="number">2</span><span class="operator">]</span>;
     <span class="keyword">if</span> (file<span class="operator">-</span><span class="operator">&gt;</span>peek(buf<span class="operator">,</span> <span class="keyword">sizeof</span>(buf)) <span class="operator">=</span><span class="operator">=</span> <span class="keyword">sizeof</span>(buf))
         <span class="keyword">return</span> (buf<span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> <span class="char">'M'</span> <span class="operator">&amp;</span><span class="operator">&amp;</span> buf<span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span><span class="operator">=</span> <span class="char">'Z'</span>);
     <span class="keyword">return</span> <span class="keyword">false</span>;
 }
</pre>
<p>这个函数是Qt 4.1中引入。</p>
<p><b>See also</b> <a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（ ） 。</p>


<h3 class="fn">
<a name="pos"></a>int QIODevice.pos (<i>self</i>)</h3>
<p>对于随机存取设备，此函数返回的数据被写入或读出的位置。对于顺序装置或封闭装置，其中有一个“当前位置”的概念，则返回0 。</p>
<p>该设备的当前读/写位置在内部保持由<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>，所以重新实现这个功能是没有必要的。当子类<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>，使用<a href="qiodevice.html#seek" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#seek">QIODevice.seek</a>（ ）通知<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>的变化在设备中的位置。</p>
<p><b>See also</b> <a href="qiodevice.html#isSequential" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isSequential">isSequential</a>（）和<a href="qiodevice.html#seek" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#seek">seek</a>（ ） 。</p>


<h3 class="fn">
<a name="putChar"></a>bool QIODevice.putChar (<i>self</i>, str <i>c</i>)</h3>
<p>写入字符<i>c</i>到设备。成功时返回TRUE ，否则返回False 。</p>
<p><b>See also</b> <a href="qiodevice.html#write" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#write">write</a>（ ）<a href="qiodevice.html#getChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#getChar">getChar</a>（）和<a href="qiodevice.html#ungetChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#ungetChar">ungetChar</a>（ ） 。</p>


<h3 class="fn">
<a name="read"></a>str QIODevice.read (<i>self</i>, int <i>maxlen</i>)</h3>
<p>阅读次数最多<i>maxSize</i>从设备到字节<i>data</i>，并返回读取的字节数。如果发生错误，则尝试从在打开的设备来读取时，如<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">WriteOnly</a>模式下，该函数返回-1 。</p>
<p>当没有更多的数据可供读取返回0。不过，过去读的流的末尾被认为是一个错误，所以这个函数返回-1在这种情况下（即，读一个已关闭的套接字或之后的过程已经去世） 。</p>
<p><b>See also</b> <a href="qiodevice.html#readData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readData">readData</a>（ ）<a href="qiodevice.html#readLine" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLine">readLine</a>（）和<a href="qiodevice.html#write" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#write">write</a>（ ） 。</p>


<h3 class="fn">
<a name="readAll"></a><a href="qbytearray.html" tppabs="http://pyqt4doc.appspot.com/qbytearray.html">QByteArray</a> QIODevice.readAll (<i>self</i>)</h3>
<p>这是一个重载函数。</p>
<p>从设备上读取所有可用的数据，并将其作为一个<a href="qbytearray.html" tppabs="http://pyqt4doc.appspot.com/qbytearray.html">QByteArray</a>。</p>
<p>此函数没有办法报告错误;返回一个空QByteArray中（ ）可能意味着要么没有数据是目前可用于阅读，或发生了错误。</p>


<h3 class="fn">
<a name="readData"></a>str QIODevice.readData (<i>self</i>, int <i>maxlen</i>)</h3>
<p>这种方法是抽象的，应在任何子类中重新实现。</p>
<p>读取高达<i>maxSize</i>从设备到字节<i>data</i>，并返回读取的字节数或-1，如果发生了错误。</p>
<p>如果没有字节被读取并永远不会有更多可用的字节（例子包括插座关闭，管道关闭，子进程结束） ，该函数返回-1 。</p>
<p>调用此函数由<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>。创建的子类时重新实现此功能<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>。</p>
<p>当重新实现这个功能是很重要的，这个函数读取所有需要的数据，然后返回。这是必需的，以便<a href="qdatastream.html" tppabs="http://pyqt4doc.appspot.com/qdatastream.html">QDataStream</a>要能够对类进行操作。<a href="qdatastream.html" tppabs="http://pyqt4doc.appspot.com/qdatastream.html">QDataStream</a>假设所有请求的信息被读取，因此不会重试阅读，如果有问题。</p>
<p><b>See also</b> <a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（ ）<a href="qiodevice.html#readLine" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLine">readLine</a>（）和<a href="qiodevice.html#writeData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#writeData">writeData</a>（ ） 。</p>


<h3 class="fn">
<a name="readLine"></a>str QIODevice.readLine (<i>self</i>, int <i>maxlen</i> = 0)</h3>
<p>该函数读取一行的从设备的ASCII字符，最多的<i>maxSize</i> - 1个字节，存储在字符<i>data</i>，并返回读取的字节数。如果某行不能被读取，但没有错误发生，则该函数返回0 。如果发生错误，此函数返回什么可以读取的长度，或-1，如果没有被读取。</p>
<p>一个终端'\ 0'字节总是附加到<i>data</i>，所以<i>maxSize</i>必须大于1。</p>
<p>数据被读取，直到下列任一条件满足：</p>
<ul>
<li>The first '\n' character is read.</li>
<li>
<i>maxSize</i> - 1 bytes are read.</li>
<li>The end of the device data is detected.</li>
</ul>
<p>例如，下面的代码读取一行从文件中的字符：</p>
<pre class="cpp">
 <span class="type"><a href="qfile.html" tppabs="http://pyqt4doc.appspot.com/qfile.html">QFile</a></span> file(<span class="string">"box.txt"</span>);
 <span class="keyword">if</span> (file<span class="operator">.</span>open(<span class="type"><a href="qfile.html" tppabs="http://pyqt4doc.appspot.com/qfile.html">QFile</a></span><span class="operator">.</span>ReadOnly)) {
     <span class="type">char</span> buf<span class="operator">[</span><span class="number">1024</span><span class="operator">]</span>;
     <span class="type"><a href="index.htm#qint64-typedef" tppabs="http://pyqt4doc.appspot.com/qtcore.html#qint64-typedef">long</a></span> lineLength <span class="operator">=</span> file<span class="operator">.</span>readLine(buf<span class="operator">,</span> <span class="keyword">sizeof</span>(buf));
     <span class="keyword">if</span> (lineLength <span class="operator">!</span><span class="operator">=</span> <span class="operator">-</span><span class="number">1</span>) {
         <span class="comment">// the line is available in buf</span>
     }
 }
</pre>
<p>换行符（ '\ n'）时包含在缓冲区中。如果一个换行符MAXSIZE之前没有遇到过 - 1字节被读取，换行不会被插入到缓冲区。在windows换行符替换为'\ n ' 。</p>
<p>此函数调用<a href="qiodevice.html#readLineData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLineData">readLineData</a>（ ） ，这是使用重复调用实现<a href="qiodevice.html#getChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#getChar">getChar</a>（ ） 。您可以通过重新实现提供更有效的实现<a href="qiodevice.html#readLineData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLineData">readLineData</a>（ ）在自己的子类。</p>
<p><b>See also</b> <a href="qiodevice.html#getChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#getChar">getChar</a>（ ）<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（）和<a href="qiodevice.html#write" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#write">write</a>（ ） 。</p>


<h3 class="fn">
<a name="readLineData"></a>str QIODevice.readLineData (<i>self</i>, int <i>maxlen</i>)</h3>
<p>读取高达<i>maxSize</i>字符转换成<i>data</i>并返回读取的字符数。</p>
<p>调用此函数由<a href="qiodevice.html#readLine" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLine">readLine</a>（ ） ，并提供了其基本的实现，用<a href="qiodevice.html#getChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#getChar">getChar</a>（ ） 。缓冲装置可改善性能<a href="qiodevice.html#readLine" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLine">readLine</a>（ ）通过重新实现此功能。</p>
<p><a href="qiodevice.html#readLine" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readLine">readLine</a>（ ）添加一个'\ 0'字节<i>data</i>; readLineData （ ）并不需要这样做。</p>
<p>如果你重新实现这个功能，要小心返回正确的值：它应该返回读取此行的字节数，包括终止换行符，或者0，如果没有行被读取了这一点。如果发生错误，它应该返回-1 ，当且仅当没有字节被读取。阅读过去的EOF被认为是一个错误。</p>


<h3 class="fn">
<a name="reset"></a>bool QIODevice.reset (<i>self</i>)</h3>
<p>搜索到输入的开始随机访问设备。成功时返回TRUE ，否则返回False （例如，如果设备没有打开） 。</p>
<p>使用时需要注意的是一<a href="qtextstream.html" tppabs="http://pyqt4doc.appspot.com/qtextstream.html">QTextStream</a>上一个<a href="qfile.html" tppabs="http://pyqt4doc.appspot.com/qfile.html">QFile</a>，在调用复位（ ）<a href="qfile.html" tppabs="http://pyqt4doc.appspot.com/qfile.html">QFile</a>不会有预期的结果，因为<a href="qtextstream.html" tppabs="http://pyqt4doc.appspot.com/qtextstream.html">QTextStream</a>缓冲文件。使用<a href="qtextstream.html#seek" tppabs="http://pyqt4doc.appspot.com/qtextstream.html#seek">QTextStream.seek</a>（ ）函数来代替。</p>
<p><b>See also</b> <a href="qiodevice.html#seek" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#seek">seek</a>（ ） 。</p>


<h3 class="fn">
<a name="seek"></a>bool QIODevice.seek (<i>self</i>, int <i>pos</i>)</h3>
<p>对于随机存取设备，此函数设置当前位置<i>pos</i>，返回True表示成功，或False，如果发生了错误。对于顺序的设备，默认的行为是什么都不做，返回False 。</p>
<p>当子类<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>，你必须调用QIODevice.seek （ ）在你的函数的开头，以确保与诚信<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>的内置缓冲。基实现总是返回True 。</p>
<p><b>See also</b> <a href="qiodevice.html#pos" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#pos">pos</a>（）和<a href="qiodevice.html#isSequential" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isSequential">isSequential</a>（ ） 。</p>


<h3 class="fn">
<a name="setErrorString"></a>QIODevice.setErrorString (<i>self</i>, QString <i>errorString</i>)</h3>
<p>设置发生在最后一个设备错误的可读描述<i>str</i>。</p>
<p><b>See also</b> <a href="qiodevice.html#errorString" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#errorString">errorString</a>（ ） 。</p>


<h3 class="fn">
<a name="setOpenMode"></a>QIODevice.setOpenMode (<i>self</i>, <a href="index.htm" tppabs="http://pyqt4doc.appspot.com/qiodevice-openmode.html">OpenMode</a> <i>openMode</i>)</h3>
<p>设置<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenMode</a>该设备的<i>openMode</i>。调用此函数来设置开放模式，如果该设备已被打开后旗更改。</p>
<p><b>See also</b> <a href="qiodevice.html#openMode" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#openMode">openMode</a>（）和<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">OpenMode</a>。</p>


<h3 class="fn">
<a name="setTextModeEnabled"></a>QIODevice.setTextModeEnabled (<i>self</i>, bool <i>enabled</i>)</h3>
<p>If <i>enabled</i>诚然，这个功能设置<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">Text</a>标志装置上，否则<a href="qiodevice.html#OpenModeFlag-enum" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#OpenModeFlag-enum">Text</a>标志被清除。此功能对于提供定制行尾类的处理上很有用<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>。</p>
<p>IO设备应调用此函数之前被打开。</p>
<p><b>See also</b> <a href="qiodevice.html#isTextModeEnabled" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isTextModeEnabled">isTextModeEnabled</a>（ ）<a href="qiodevice.html#open" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#open">open</a>（）和<a href="qiodevice.html#setOpenMode" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#setOpenMode">setOpenMode</a>（ ） 。</p>


<h3 class="fn">
<a name="size"></a>int QIODevice.size (<i>self</i>)</h3>
<p>为开放的随机存取设备，则该函数返回该装置的尺寸。对于打开的顺序设备，<a href="qiodevice.html#bytesAvailable" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesAvailable">bytesAvailable</a>（ ）返回。</p>
<p>如果设备被关闭，返回的大小不会反映设备的实际大小。</p>
<p><b>See also</b> <a href="qiodevice.html#isSequential" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#isSequential">isSequential</a>（）和<a href="qiodevice.html#pos" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#pos">pos</a>（ ） 。</p>


<h3 class="fn">
<a name="ungetChar"></a>QIODevice.ungetChar (<i>self</i>, str <i>c</i>)</h3>
<p>把字符<i>c</i>返回到设备，并减少当前位置，除非该位置为0 。此功能通常被称为“撤销”一<a href="qiodevice.html#getChar" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#getChar">getChar</a>（）操作，记录一个回溯解析器时，例如。</p>
<p>If <i>c</i>是不是从以前的设备读取，行为是未定义的。</p>


<h3 class="fn">
<a name="waitForBytesWritten"></a>bool QIODevice.waitForBytesWritten (<i>self</i>, int <i>msecs</i>)</h3>
<p>用于缓冲的装置，该函数将等待直到缓冲写入的数据的有效载荷中已写入的装置和<a href="qiodevice.html#bytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesWritten">bytesWritten</a>（）信号已被发出，或直到<i>msecs</i>毫秒过去了。如果毫秒为-1 ，此功能将不会超时。对于无缓冲装置，它会立即返回。</p>
<p>返回True如果数据的有效载荷被写入到设备，否则返回False （也就是说，如果操作超时，或者如果发生错误） 。</p>
<p>此功能可以操作没有一个事件循环。编写非GUI的应用程序和在非GUI线程执行I / O操作时，它是有用的。</p>
<p>如果从连接到一个时隙内的称为<a href="qiodevice.html#bytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesWritten">bytesWritten</a>（ ）信号，<a href="qiodevice.html#bytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesWritten">bytesWritten</a>（ ）将不会被重新发射。</p>
<p>重新实现这个函数提供一个阻塞的API自定义设备。默认实现不执行任何操作，并返回False 。</p>
<p><b>Warning:</b>从主（图形用户界面）线程调用该函数可能会导致你的用户界面冻结。</p>
<p><b>See also</b> <a href="qiodevice.html#waitForReadyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#waitForReadyRead">waitForReadyRead</a>（ ） 。</p>


<h3 class="fn">
<a name="waitForReadyRead"></a>bool QIODevice.waitForReadyRead (<i>self</i>, int <i>msecs</i>)</h3>
<p>阻塞，直到新的数据可供读取和<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（）信号已被发出，或直到<i>msecs</i>毫秒过去了。如果毫秒为-1 ，此功能将不会超时。</p>
<p>如果新的数据可供读取，则返回True ，否则返回False （如果操作超时，或者如果发生错误） 。</p>
<p>此功能可以操作没有一个事件循环。编写非GUI的应用程序和在非GUI线程执行I / O操作时，它是有用的。</p>
<p>如果从连接到一个时隙内的称为<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（ ）信号，<a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（ ）将不会被重新发射。</p>
<p>重新实现这个函数提供一个阻塞的API自定义设备。默认实现不执行任何操作，并返回False 。</p>
<p><b>Warning:</b>从主（图形用户界面）线程调用该函数可能会导致你的用户界面冻结。</p>
<p><b>See also</b> <a href="qiodevice.html#waitForBytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#waitForBytesWritten">waitForBytesWritten</a>（ ） 。</p>


<h3 class="fn">
<a name="write"></a>int QIODevice.write (<i>self</i>, <a href="qbytearray.html" tppabs="http://pyqt4doc.appspot.com/qbytearray.html">QByteArray</a> <i>data</i>)</h3>
<p>写在最<i>maxSize</i>数据从字节<i>data</i>到设备。返回实际写入的，或者-1如果发生错误的字节数。</p>
<p><b>See also</b> <a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（）和<a href="qiodevice.html#writeData" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#writeData">writeData</a>（ ） 。</p>


<h3 class="fn">
<a name="writeData"></a>int QIODevice.writeData (<i>self</i>, str <i>data</i>)</h3>
<p>这种方法是抽象的，应在任何子类中重新实现。</p>
<p>写入速度达<i>maxSize</i>从字节<i>data</i>到设备。返回写入的字节数，或-1，如果发生了错误。</p>
<p>调用此函数由<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>。创建的子类时重新实现此功能<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>。</p>
<p>当重新实现这个功能是很重要的，这个函数将所有可用的返回之前的数据。这是必需的，以便<a href="qdatastream.html" tppabs="http://pyqt4doc.appspot.com/qdatastream.html">QDataStream</a>要能够对类进行操作。<a href="qdatastream.html" tppabs="http://pyqt4doc.appspot.com/qdatastream.html">QDataStream</a>假设所有的信息写入，因此不会重试写，如果有一个问题。</p>
<p><b>See also</b> <a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（）和<a href="qiodevice.html#write" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#write">write</a>（ ） 。</p>
<hr>
<h2>Qt Signal Documentation</h2>
<h3 class="fn">
<a name="aboutToClose"></a>void aboutToClose ()</h3>
<p>这是该信号的默认超载。</p>
<p>时，该设备在关闭这个信号被发射。如果您有需要装置关闭之前执行（例如，如果你有数据需要被写入到设备的单独缓冲器）操作连接这个信号。</p>


<h3 class="fn">
<a name="bytesWritten"></a>void bytesWritten (qint64)</h3>
<p>这是该信号的默认超载。</p>
<p>每一数据的有效载荷已经被写入到设备时，这个信号被发射。该<i>bytes</i>参数设置为写在这个有效载荷的字节数。</p>
<p>bytesWritten （ ）是不是递归发出，如果你重新进入事件循环或致电<a href="qiodevice.html#waitForBytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#waitForBytesWritten">waitForBytesWritten</a>（）连接到bytesWritten一个时隙内（）信号，该信号将不会再发射（尽管<a href="qiodevice.html#waitForBytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#waitForBytesWritten">waitForBytesWritten</a>（ ）可能仍然返回True ） 。</p>
<p><b>See also</b> <a href="qiodevice.html#readyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#readyRead">readyRead</a>（ ） 。</p>


<h3 class="fn">
<a name="readChannelFinished"></a>void readChannelFinished ()</h3>
<p>这是该信号的默认超载。</p>
<p>当输入（读出）数据流在该装置关闭时，这个信号被发射。它刚一闭幕时探测的发射，这意味着仍有可能适用于读取数据<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（ ） 。</p>
<p>此功能被引入Qt的4.4 。</p>
<p><b>See also</b> <a href="qiodevice.html#atEnd" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#atEnd">atEnd</a>（）和<a href="qiodevice.html#read" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#read">read</a>（ ） 。</p>


<h3 class="fn">
<a name="readyRead"></a>void readyRead ()</h3>
<p>这是该信号的默认超载。</p>
<p>每一次新的数据是可用于从设备中读取这个信号被发射。它只会再次发出一次新的数据是可用的，比如当网络数据的一个新的有效载荷已经到达您的网络套接字，或者当一个新的数据块是否已经被添加到您的设备。</p>
<p>的readyRead （ ）是不是递归发出，如果你重新进入事件循环或致电<a href="qiodevice.html#waitForReadyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#waitForReadyRead">waitForReadyRead</a>（）连接到所述的readyRead一个时隙内（）信号，该信号将不会再发射（尽管<a href="qiodevice.html#waitForReadyRead" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#waitForReadyRead">waitForReadyRead</a>（ ）可能仍然返回True ） 。</p>
<p>注意执行从派生类开发商<a href="qiodevice.html" tppabs="http://pyqt4doc.appspot.com/qiodevice.html">QIODevice</a>：你应该总是散发出的readyRead （ ）时，新的数据已经到达（不散发这不仅是因为有数据仍然可以读取你的缓冲区） 。不要发出的readyRead （ ）在其他条件。</p>
<p><b>See also</b> <a href="qiodevice.html#bytesWritten" tppabs="http://pyqt4doc.appspot.com/qiodevice.html#bytesWritten">bytesWritten</a>（ ） 。</p>


<address>
<div class="ad">
<br> 
<br><hr>
</div>
<div align="center"><table border="0" cellspacing="0" width="100%"><tr class="address">
<td align="left" width="25%">PyQt 4.10.3 for X11</td>
<td align="center" width="50%">Copyright © <a href="http://www.riverbankcomputing.com/">Riverbank Computing Ltd</a> and <a href="http://www.qtsoftware.com/">Nokia</a> 2012</td>
<td align="right" width="25%">Qt 4.8.5</td>
</tr></table></div>
</address>
</body>
</html>